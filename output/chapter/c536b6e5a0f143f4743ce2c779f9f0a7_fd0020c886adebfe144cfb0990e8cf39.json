{"pageProps":{"bookInfo":{"id":"c536b6e5a0f143f4743ce2c779f9f0a7","name":"数据结构与算法","fullPath":"F:\\passerby\\algorithm\\数据结构与算法","chapterList":[{"id":"c536b6e5a0f143f4743ce2c779f9f0a7_39d59038a85836e2c0388617d7e57295","type":"chapter","name":"01引言.md","fullPath":"F:\\passerby\\algorithm\\数据结构与算法\\01引言.md","url":"/chapter/c536b6e5a0f143f4743ce2c779f9f0a7_39d59038a85836e2c0388617d7e57295"},{"id":"c536b6e5a0f143f4743ce2c779f9f0a7_d11141211c49aee7f399e7b62e3d6f73","type":"chapter","name":"02线性表.md","fullPath":"F:\\passerby\\algorithm\\数据结构与算法\\02线性表.md","url":"/chapter/c536b6e5a0f143f4743ce2c779f9f0a7_d11141211c49aee7f399e7b62e3d6f73"},{"id":"c536b6e5a0f143f4743ce2c779f9f0a7_fd0020c886adebfe144cfb0990e8cf39","type":"chapter","name":"03栈和队列.md","fullPath":"F:\\passerby\\algorithm\\数据结构与算法\\03栈和队列.md","url":"/chapter/c536b6e5a0f143f4743ce2c779f9f0a7_fd0020c886adebfe144cfb0990e8cf39"},{"id":"c536b6e5a0f143f4743ce2c779f9f0a7_33a9b6434ce7fc34e8f3a0cd2da601af","type":"chapter","name":"04串.md","fullPath":"F:\\passerby\\algorithm\\数据结构与算法\\04串.md","url":"/chapter/c536b6e5a0f143f4743ce2c779f9f0a7_33a9b6434ce7fc34e8f3a0cd2da601af"}],"title":"03栈和队列","type":"book","url":"/book/c536b6e5a0f143f4743ce2c779f9f0a7","content":"\n    \n    \n      <div class=\"crossnote markdown-preview  \">\n      \n<h1 id=\"栈和队列\">栈和队列 </h1>\n<blockquote>\n<p>栈只允许在表的一端进行插入或删除操作，而队列只允许在表的一端进行插入操作、在另一端进行删除操作。因而，栈和队列也可以被称为操作受限的线性表</p>\n</blockquote>\n<h2 id=\"栈\">栈 </h2>\n<p>栈(stack)是一种只允许在一端进行插入和删除操作的线性表，它是一种操作受限的线性表。在表中允许进行插入和删除的一端称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong>。栈的插入操作通常称为<strong>入栈</strong>或<strong>进栈</strong>而栈的删除操作则称为<strong>出栈</strong>或<strong>退栈</strong>当栈中无数据元素时，称为<strong>空栈</strong></p>\n<p>根据栈的定义，每次进栈的元素都被放在原栈顶元素之上而成为新的栈顶，而每次出栈的总是当前栈中“最新”的元素，即最后进栈的元素;<strong>后进先出</strong></p>\n<h3 id=\"多栈共享邻接空间\">多栈共享邻接空间 </h3>\n<p>G在计算机系统软件中，各种高级语言的编译系统都离不开栈的使用。常常一个程序中要用到多个栈，若采用顺序栈，会因为所需的栈空间大小难以准确估计，导致出现有的栈空间溢出、有的栈空间空闲的情况。为了不发生上溢错误，就必须给每个栈预先分配一个足够大的存储空间，但实际中很难准确地估计。另一方面，若每个栈都预分配过大的存储空间，势必会造成系统空间紧张。紧张。若让多个栈共用一个足够大的连续存储空间，则可利用栈的动态特性使其存储空间互补。这就是栈的共享邻接空间。</p>\n<h2 id=\"应用\">应用 </h2>\n<ol>\n<li>算术表达式求值</li>\n</ol>\n<p>计值的实现可以通过设置两个栈来完成。<br>\n<strong>操作数栈(OPRD)</strong>: 用来存放处理表达是过程中的操作数<br>\n<strong>运算符栈(OPTR)</strong>: 存放处理表达式过程中的运算符，开始时，先在运算符栈栈底压入一个表达式的结束符*#*<br>\n计算机系统在处理表达式时，从左到右依次读出表达式中的各个符号（操作数或运算符），每读出一个符号后，根据运算规则做如下的处理。假如是操作数，则将其压入操作数栈，并依次读下一个符号。假如是运算符，则与运算符栈的栈顶运算符进行优先级比较，并做以以下处理</p>\n<ul>\n<li>假如读出的运算符的优先级高于运算符栈栈顶运算符的优先级，则将其压入运算符栈，并依次读下一个符号</li>\n<li>假如读出的运算符的优先级等于运算符栈栈顶运算符的优先级，说明左右括号相遇，只需将栈顶运算符退栈即可</li>\n<li>#假如读出的运算符的优先级低于运算符栈栈顶运算符的优先级，则从操作数栈连续退出两个操作数，从运算符栈中退出一个运算符，然后做相应的运算，并将运算结果压入操作数栈</li>\n<li>假如读出的是表达式结束符*#<em>，且运算符栈栈顶的运算符也为</em>#*，则表达式处理结束，最后的表达式的计算结果在操作数栈的栈顶位置</li>\n</ul>\n<p>表1 表达式3+4*2计算过程栈区变化表</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>操作数栈</th>\n<th>运算符栈</th>\n<th>尚待读入的表达式</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td></td>\n<td>#</td>\n<td>3+4*2#</td>\n<td>初始状态</td>\n</tr>\n<tr>\n<td>2</td>\n<td>3</td>\n<td>#</td>\n<td>+4*2#</td>\n<td>读入3</td>\n</tr>\n<tr>\n<td>3</td>\n<td>3</td>\n<td>#+</td>\n<td>4*2#</td>\n<td>读入+</td>\n</tr>\n<tr>\n<td>4</td>\n<td>3,4</td>\n<td>#+</td>\n<td>*2#</td>\n<td>读入4</td>\n</tr>\n<tr>\n<td>5</td>\n<td>3,4</td>\n<td>#+*</td>\n<td>2#</td>\n<td>读入2#</td>\n</tr>\n<tr>\n<td>6</td>\n<td>3,4，2</td>\n<td>#+*</td>\n<td>#</td>\n<td>读入2</td>\n</tr>\n<tr>\n<td>7</td>\n<td>3， 8</td>\n<td>#+</td>\n<td>#</td>\n<td>计算4*2</td>\n</tr>\n<tr>\n<td>8</td>\n<td>11</td>\n<td>#</td>\n<td>#</td>\n<td>计算3+8</td>\n</tr>\n<tr>\n<td>9</td>\n<td></td>\n<td></td>\n<td></td>\n<td>结束</td>\n</tr>\n</tbody>\n</table>\n<p><strong>栈与递归过程</strong></p>\n<p>栈的一个重要应用是在程序设计语言中实现递归过程。递归即在定义自身的同时又出现了对自身的调用。如果一个函数在其定义体内直接调用自己，则称其为“直接递归函数”。如果一个函数经过一系列中间调用语句，通过其他函数间接调用自己，则称其为“间接递函数归”</p>\n<p>有很多数学函数是递归定义的，如阶乘函数的定义<br>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">!</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>1</mn><mspace width=\"2em\"></mspace><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mo>×</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mspace width=\"2em\"></mspace><mi>n</mi><mo mathvariant=\"normal\">≠</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">n! = \\begin{cases}\n1 \\qquad n = 0 \\\\\nn \\times (n - 1) \\qquad n \\neq 0\n\\end{cases}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<pre data-role=\"codeBlock\" data-info=\"c#\" class=\"language-c# c#\"><code>long fact(int n)\n{\n    if(n == 0)\n    {\n        return 1;\n    } else {\n        return (n * fact(n -1));\n    }\n}\n</code></pre><p>递归算法的设计步骤如下</p>\n<ol>\n<li>将规模较大的原问题分解为一个或多个规模更小，但具有类似于原问题特性的子问题，即较大的问题递归地用较小的子问题来描述，解原问题的方法同样可用来解这些子问题</li>\n<li>确定一个或多个无须分解，可直接求解的最小子问题（称为“递归的终止条件”）</li>\n</ol>\n<p>递归算法有两个基本的特征：递归归纳和递归终止。首先能将问题转化为比原问题规模小的同类问题，归纳出一般递推公式，故所处理的对象要有规律地递增或递减；当规模小到一定的程度应结束递归调用，逐层返回</p>\n<h2 id=\"队列\">队列 </h2>\n<p>它只允许插入在表的一端进行，而删除在表的另一端进行，允许插入的一端叫队尾（rear），而允许删除的一端叫队头（front）。队列的插入操作通常称为“入队”或“进队”，而队列的删除操作则称为“出队”或“退队”;队”。当队列中无数据元素时，称为“空队列”。根据队列的定义可知，队头元素总是最先进队列，也总是最先出队列；队尾元素总是最后进队列，因而也是最后出队列。这种表是按照先进先出（first in first out FIFO）的原则组织数据的，因此，队列也被称为“先进先出”表</p>\n<h2 id=\"分治法\">分治法 </h2>\n<p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单地直接求解，原问题的解即子问题的解的合并</p>\n<p>任何一个可以用计算机求解的问题，其所需的计算时间都与规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少</p>\n<p>分治法所能解决的问题一般具有以下几个特征。</p>\n<ul>\n<li>该问题的规模缩小到一定的程度就可以容易地解决。</li>\n<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>\n<li>利用该问题分解出的子问题的解可以合并为该问题的解。</li>\n<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题</li>\n</ul>\n<p>分治法在每一层递归上都有如下三个步骤</p>\n<ol>\n<li>分解：将原问题分解为若干个规模较小、相互独立，且与原问题形式相同的子问题。</li>\n<li>解决：若子问题规模较小且容易被解决则直接解，否则递归地解各个子问题。</li>\n<li>合并：将各个子问题的解合并为原问题的解。</li>\n</ol>\n<p><a href=\"https://ebook.hep.com.cn/index.html#/reader?bookId=1061913534566236161\">原文地址</a></p>\n\n      </div>\n      <div class=\"md-sidebar-toc\">\n<div class=\"md-toc\">\n<details style=\"padding:0;;padding-left:0px;\" open=\"\">\n        <summary class=\"md-toc-link-wrapper\">\n          <a href=\"#栈和队列\" class=\"md-toc-link\"><p>栈和队列</p>\n</a>\n          </summary>\n        <div>\n          <details style=\"padding:0;;padding-left:24px;\" open=\"\">\n        <summary class=\"md-toc-link-wrapper\">\n          <a href=\"#栈\" class=\"md-toc-link\"><p>栈</p>\n</a>\n          </summary>\n        <div>\n          <div class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\">\n          <a href=\"#多栈共享邻接空间\" class=\"md-toc-link\">\n            <p>多栈共享邻接空间</p>\n\n          </a></div>\n        </div>\n      </details>\n    <div class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\">\n          <a href=\"#应用\" class=\"md-toc-link\">\n            <p>应用</p>\n\n          </a></div><div class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\">\n          <a href=\"#队列\" class=\"md-toc-link\">\n            <p>队列</p>\n\n          </a></div><div class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\">\n          <a href=\"#分治法\" class=\"md-toc-link\">\n            <p>分治法</p>\n\n          </a></div>\n        </div>\n      </details>\n    \n</div>\n</div>\n      <a id=\"sidebar-toc-btn\">≡</a>\n    \n    \n    \n    \n    \n    \n<script>\n\nvar sidebarTOCBtn = document.getElementById('sidebar-toc-btn')\nsidebarTOCBtn.addEventListener('click', function(event) {\n  event.stopPropagation()\n  if (document.body.hasAttribute('html-show-sidebar-toc')) {\n    document.body.removeAttribute('html-show-sidebar-toc')\n  } else {\n    document.body.setAttribute('html-show-sidebar-toc', true)\n  }\n})\n</script>\n      \n  \n    "},"title":"03栈和队列"},"__N_SSG":true}