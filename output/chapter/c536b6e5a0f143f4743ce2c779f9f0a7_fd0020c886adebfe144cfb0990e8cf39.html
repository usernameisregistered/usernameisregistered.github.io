<!DOCTYPE html><html lang="zh-cn"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head=""></title><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/static/css/dfcb762f96d35f65.css" as="style"/><link rel="stylesheet" href="/static/css/dfcb762f96d35f65.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/static/chunks/webpack-a9de24c27879d5d9.js" defer=""></script><script src="/static/chunks/framework-a4ddb9b21624b39b.js" defer=""></script><script src="/static/chunks/main-40e151073ba9b914.js" defer=""></script><script src="/static/chunks/pages/_app-c801a419d8851d78.js" defer=""></script><script src="/static/chunks/121-ea166289b6b9b64f.js" defer=""></script><script src="/static/chunks/278-09ee5e026e1c614e.js" defer=""></script><script src="/static/chunks/pages/chapter/%5BchapterId%5D-a26c039fdd7871a6.js" defer=""></script><script src="/static/VY6YhJCpFetLWoMetjDAA/_buildManifest.js" defer=""></script><script src="/static/VY6YhJCpFetLWoMetjDAA/_ssgManifest.js" defer=""></script></head><body data-for="html-export" class="antialiased"><div id="__next"><div class="w-screen flex flex-col h-screen"><header class="flex flex-grow-0 justify-between p-4 border-b border-neutral-200"><a class="flex items-center text-2xl text-neutral-700 cursor-pointer" href="/"><img alt="得鹿梦鱼" loading="lazy" width="40" height="40" decoding="async" data-nimg="1" style="color:transparent" src="/logo.svg"/><span class="text-4 ml-4">得鹿梦鱼</span></a><div class="right flex items-center cursor-pointer"><a class="mr-2  text-md " href="/classify">知识库</a><a class="mr-2  text-md " href="/frontend">前端技能树</a><a class="mr-2  text-md " href="/study">学习资料</a><a class="mr-2  text-md " href="/about">关于本人</a></div></header><div class="w-screen flex flex-1"><aside class="basis-2/12 border-r border-gray-300 h-full overflow-hidden"><div class="text-md font-bold text-gray-700 m-4">数据结构与算法</div><div dir="ltr" class="relative overflow-hidden scroll--chapter-height" style="position:relative;--radix-scroll-area-corner-width:0px;--radix-scroll-area-corner-height:0px"><style>[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}</style><div data-radix-scroll-area-viewport="" class="h-full w-full rounded-[inherit]" style="overflow-x:hidden;overflow-y:hidden"><div style="min-width:100%;display:table"><a class="text-md text-gray-600 block mx-4 mb-2 cursor-pointer overflow-hidden text-ellipsis whitespace-nowrap hover:text-sky-300" href="/chapter/c536b6e5a0f143f4743ce2c779f9f0a7_39d59038a85836e2c0388617d7e57295">01引言.md</a><a class="text-md text-gray-600 block mx-4 mb-2 cursor-pointer overflow-hidden text-ellipsis whitespace-nowrap hover:text-sky-300" href="/chapter/c536b6e5a0f143f4743ce2c779f9f0a7_d11141211c49aee7f399e7b62e3d6f73">02线性表.md</a><a class="text-md text-sky-300 block mx-4 mb-2 cursor-pointer overflow-hidden text-ellipsis whitespace-nowrap hover:text-sky-300" href="/chapter/c536b6e5a0f143f4743ce2c779f9f0a7_fd0020c886adebfe144cfb0990e8cf39">03栈和队列.md</a><a class="text-md text-gray-600 block mx-4 mb-2 cursor-pointer overflow-hidden text-ellipsis whitespace-nowrap hover:text-sky-300" href="/chapter/c536b6e5a0f143f4743ce2c779f9f0a7_33a9b6434ce7fc34e8f3a0cd2da601af">04串.md</a></div></div></div></aside><section class="basis-10/12 flex flex-col p-1"><div class="flex-1"><div dir="ltr" class="relative overflow-hidden scroll-content-height" style="position:relative;--radix-scroll-area-corner-width:0px;--radix-scroll-area-corner-height:0px"><style>[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}</style><div data-radix-scroll-area-viewport="" class="h-full w-full rounded-[inherit]" style="overflow-x:hidden;overflow-y:hidden"><div style="min-width:100%;display:table"><div id="markdown-container">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="栈和队列">栈和队列 </h1>
<blockquote>
<p>栈只允许在表的一端进行插入或删除操作，而队列只允许在表的一端进行插入操作、在另一端进行删除操作。因而，栈和队列也可以被称为操作受限的线性表</p>
</blockquote>
<h2 id="栈">栈 </h2>
<p>栈(stack)是一种只允许在一端进行插入和删除操作的线性表，它是一种操作受限的线性表。在表中允许进行插入和删除的一端称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong>。栈的插入操作通常称为<strong>入栈</strong>或<strong>进栈</strong>而栈的删除操作则称为<strong>出栈</strong>或<strong>退栈</strong>当栈中无数据元素时，称为<strong>空栈</strong></p>
<p>根据栈的定义，每次进栈的元素都被放在原栈顶元素之上而成为新的栈顶，而每次出栈的总是当前栈中“最新”的元素，即最后进栈的元素;<strong>后进先出</strong></p>
<h3 id="多栈共享邻接空间">多栈共享邻接空间 </h3>
<p>G在计算机系统软件中，各种高级语言的编译系统都离不开栈的使用。常常一个程序中要用到多个栈，若采用顺序栈，会因为所需的栈空间大小难以准确估计，导致出现有的栈空间溢出、有的栈空间空闲的情况。为了不发生上溢错误，就必须给每个栈预先分配一个足够大的存储空间，但实际中很难准确地估计。另一方面，若每个栈都预分配过大的存储空间，势必会造成系统空间紧张。紧张。若让多个栈共用一个足够大的连续存储空间，则可利用栈的动态特性使其存储空间互补。这就是栈的共享邻接空间。</p>
<h2 id="应用">应用 </h2>
<ol>
<li>算术表达式求值</li>
</ol>
<p>计值的实现可以通过设置两个栈来完成。<br>
<strong>操作数栈(OPRD)</strong>: 用来存放处理表达是过程中的操作数<br>
<strong>运算符栈(OPTR)</strong>: 存放处理表达式过程中的运算符，开始时，先在运算符栈栈底压入一个表达式的结束符*#*<br>
计算机系统在处理表达式时，从左到右依次读出表达式中的各个符号（操作数或运算符），每读出一个符号后，根据运算规则做如下的处理。假如是操作数，则将其压入操作数栈，并依次读下一个符号。假如是运算符，则与运算符栈的栈顶运算符进行优先级比较，并做以以下处理</p>
<ul>
<li>假如读出的运算符的优先级高于运算符栈栈顶运算符的优先级，则将其压入运算符栈，并依次读下一个符号</li>
<li>假如读出的运算符的优先级等于运算符栈栈顶运算符的优先级，说明左右括号相遇，只需将栈顶运算符退栈即可</li>
<li>#假如读出的运算符的优先级低于运算符栈栈顶运算符的优先级，则从操作数栈连续退出两个操作数，从运算符栈中退出一个运算符，然后做相应的运算，并将运算结果压入操作数栈</li>
<li>假如读出的是表达式结束符*#<em>，且运算符栈栈顶的运算符也为</em>#*，则表达式处理结束，最后的表达式的计算结果在操作数栈的栈顶位置</li>
</ul>
<p>表1 表达式3+4*2计算过程栈区变化表</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>操作数栈</th>
<th>运算符栈</th>
<th>尚待读入的表达式</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td></td>
<td>#</td>
<td>3+4*2#</td>
<td>初始状态</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>#</td>
<td>+4*2#</td>
<td>读入3</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>#+</td>
<td>4*2#</td>
<td>读入+</td>
</tr>
<tr>
<td>4</td>
<td>3,4</td>
<td>#+</td>
<td>*2#</td>
<td>读入4</td>
</tr>
<tr>
<td>5</td>
<td>3,4</td>
<td>#+*</td>
<td>2#</td>
<td>读入2#</td>
</tr>
<tr>
<td>6</td>
<td>3,4，2</td>
<td>#+*</td>
<td>#</td>
<td>读入2</td>
</tr>
<tr>
<td>7</td>
<td>3， 8</td>
<td>#+</td>
<td>#</td>
<td>计算4*2</td>
</tr>
<tr>
<td>8</td>
<td>11</td>
<td>#</td>
<td>#</td>
<td>计算3+8</td>
</tr>
<tr>
<td>9</td>
<td></td>
<td></td>
<td></td>
<td>结束</td>
</tr>
</tbody>
</table>
<p><strong>栈与递归过程</strong></p>
<p>栈的一个重要应用是在程序设计语言中实现递归过程。递归即在定义自身的同时又出现了对自身的调用。如果一个函数在其定义体内直接调用自己，则称其为“直接递归函数”。如果一个函数经过一系列中间调用语句，通过其他函数间接调用自己，则称其为“间接递函数归”</p>
<p>有很多数学函数是递归定义的，如阶乘函数的定义<br>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mspace width="2em"></mspace><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mspace width="2em"></mspace><mi>n</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">n! = \begin{cases}
1 \qquad n = 0 \\
n \times (n - 1) \qquad n \neq 0
\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:2em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:2em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<pre data-role="codeBlock" data-info="c#" class="language-c# c#"><code>long fact(int n)
{
    if(n == 0)
    {
        return 1;
    } else {
        return (n * fact(n -1));
    }
}
</code></pre><p>递归算法的设计步骤如下</p>
<ol>
<li>将规模较大的原问题分解为一个或多个规模更小，但具有类似于原问题特性的子问题，即较大的问题递归地用较小的子问题来描述，解原问题的方法同样可用来解这些子问题</li>
<li>确定一个或多个无须分解，可直接求解的最小子问题（称为“递归的终止条件”）</li>
</ol>
<p>递归算法有两个基本的特征：递归归纳和递归终止。首先能将问题转化为比原问题规模小的同类问题，归纳出一般递推公式，故所处理的对象要有规律地递增或递减；当规模小到一定的程度应结束递归调用，逐层返回</p>
<h2 id="队列">队列 </h2>
<p>它只允许插入在表的一端进行，而删除在表的另一端进行，允许插入的一端叫队尾（rear），而允许删除的一端叫队头（front）。队列的插入操作通常称为“入队”或“进队”，而队列的删除操作则称为“出队”或“退队”;队”。当队列中无数据元素时，称为“空队列”。根据队列的定义可知，队头元素总是最先进队列，也总是最先出队列；队尾元素总是最后进队列，因而也是最后出队列。这种表是按照先进先出（first in first out FIFO）的原则组织数据的，因此，队列也被称为“先进先出”表</p>
<h2 id="分治法">分治法 </h2>
<p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单地直接求解，原问题的解即子问题的解的合并</p>
<p>任何一个可以用计算机求解的问题，其所需的计算时间都与规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少</p>
<p>分治法所能解决的问题一般具有以下几个特征。</p>
<ul>
<li>该问题的规模缩小到一定的程度就可以容易地解决。</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解。</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题</li>
</ul>
<p>分治法在每一层递归上都有如下三个步骤</p>
<ol>
<li>分解：将原问题分解为若干个规模较小、相互独立，且与原问题形式相同的子问题。</li>
<li>解决：若子问题规模较小且容易被解决则直接解，否则递归地解各个子问题。</li>
<li>合并：将各个子问题的解合并为原问题的解。</li>
</ol>
<p><a href="https://ebook.hep.com.cn/index.html#/reader?bookId=1061913534566236161">原文地址</a></p>

      </div>
      <div class="md-sidebar-toc">
<div class="md-toc">
<details style="padding:0;;padding-left:0px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#栈和队列" class="md-toc-link"><p>栈和队列</p>
</a>
          </summary>
        <div>
          <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#栈" class="md-toc-link"><p>栈</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#多栈共享邻接空间" class="md-toc-link">
            <p>多栈共享邻接空间</p>

          </a></div>
        </div>
      </details>
    <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#应用" class="md-toc-link">
            <p>应用</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#队列" class="md-toc-link">
            <p>队列</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#分治法" class="md-toc-link">
            <p>分治法</p>

          </a></div>
        </div>
      </details>
    
</div>
</div>
      <a id="sidebar-toc-btn">≡</a>
    
    
    
    
    
    
<script>

var sidebarTOCBtn = document.getElementById('sidebar-toc-btn')
sidebarTOCBtn.addEventListener('click', function(event) {
  event.stopPropagation()
  if (document.body.hasAttribute('html-show-sidebar-toc')) {
    document.body.removeAttribute('html-show-sidebar-toc')
  } else {
    document.body.setAttribute('html-show-sidebar-toc', true)
  }
})
</script>
      
  
    </div></div></div></div></div><div class="flex justify-between"><div class="visible border min-w-60 h-10 px-4 leading-10 border-gray-300 text-center cursor-pointer rounded-md hover:text-sky-300">02线性表.md</div><div class="visible border min-w-60 px-4  h-10 leading-10 border-gray-300 text-center cursor-pointer rounded-md hover:text-sky-300">04串.md</div></div></section></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"bookInfo":{"id":"c536b6e5a0f143f4743ce2c779f9f0a7","name":"数据结构与算法","fullPath":"F:\\passerby\\algorithm\\数据结构与算法","chapterList":[{"id":"c536b6e5a0f143f4743ce2c779f9f0a7_39d59038a85836e2c0388617d7e57295","type":"chapter","name":"01引言.md","fullPath":"F:\\passerby\\algorithm\\数据结构与算法\\01引言.md","url":"/chapter/c536b6e5a0f143f4743ce2c779f9f0a7_39d59038a85836e2c0388617d7e57295"},{"id":"c536b6e5a0f143f4743ce2c779f9f0a7_d11141211c49aee7f399e7b62e3d6f73","type":"chapter","name":"02线性表.md","fullPath":"F:\\passerby\\algorithm\\数据结构与算法\\02线性表.md","url":"/chapter/c536b6e5a0f143f4743ce2c779f9f0a7_d11141211c49aee7f399e7b62e3d6f73"},{"id":"c536b6e5a0f143f4743ce2c779f9f0a7_fd0020c886adebfe144cfb0990e8cf39","type":"chapter","name":"03栈和队列.md","fullPath":"F:\\passerby\\algorithm\\数据结构与算法\\03栈和队列.md","url":"/chapter/c536b6e5a0f143f4743ce2c779f9f0a7_fd0020c886adebfe144cfb0990e8cf39"},{"id":"c536b6e5a0f143f4743ce2c779f9f0a7_33a9b6434ce7fc34e8f3a0cd2da601af","type":"chapter","name":"04串.md","fullPath":"F:\\passerby\\algorithm\\数据结构与算法\\04串.md","url":"/chapter/c536b6e5a0f143f4743ce2c779f9f0a7_33a9b6434ce7fc34e8f3a0cd2da601af"}],"title":"03栈和队列","type":"book","url":"/book/c536b6e5a0f143f4743ce2c779f9f0a7","content":"\n    \n    \n      \u003cdiv class=\"crossnote markdown-preview  \"\u003e\n      \n\u003ch1 id=\"栈和队列\"\u003e栈和队列 \u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e栈只允许在表的一端进行插入或删除操作，而队列只允许在表的一端进行插入操作、在另一端进行删除操作。因而，栈和队列也可以被称为操作受限的线性表\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"栈\"\u003e栈 \u003c/h2\u003e\n\u003cp\u003e栈(stack)是一种只允许在一端进行插入和删除操作的线性表，它是一种操作受限的线性表。在表中允许进行插入和删除的一端称为\u003cstrong\u003e栈顶\u003c/strong\u003e，另一端称为\u003cstrong\u003e栈底\u003c/strong\u003e。栈的插入操作通常称为\u003cstrong\u003e入栈\u003c/strong\u003e或\u003cstrong\u003e进栈\u003c/strong\u003e而栈的删除操作则称为\u003cstrong\u003e出栈\u003c/strong\u003e或\u003cstrong\u003e退栈\u003c/strong\u003e当栈中无数据元素时，称为\u003cstrong\u003e空栈\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e根据栈的定义，每次进栈的元素都被放在原栈顶元素之上而成为新的栈顶，而每次出栈的总是当前栈中“最新”的元素，即最后进栈的元素;\u003cstrong\u003e后进先出\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"多栈共享邻接空间\"\u003e多栈共享邻接空间 \u003c/h3\u003e\n\u003cp\u003eG在计算机系统软件中，各种高级语言的编译系统都离不开栈的使用。常常一个程序中要用到多个栈，若采用顺序栈，会因为所需的栈空间大小难以准确估计，导致出现有的栈空间溢出、有的栈空间空闲的情况。为了不发生上溢错误，就必须给每个栈预先分配一个足够大的存储空间，但实际中很难准确地估计。另一方面，若每个栈都预分配过大的存储空间，势必会造成系统空间紧张。紧张。若让多个栈共用一个足够大的连续存储空间，则可利用栈的动态特性使其存储空间互补。这就是栈的共享邻接空间。\u003c/p\u003e\n\u003ch2 id=\"应用\"\u003e应用 \u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e算术表达式求值\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e计值的实现可以通过设置两个栈来完成。\u003cbr\u003e\n\u003cstrong\u003e操作数栈(OPRD)\u003c/strong\u003e: 用来存放处理表达是过程中的操作数\u003cbr\u003e\n\u003cstrong\u003e运算符栈(OPTR)\u003c/strong\u003e: 存放处理表达式过程中的运算符，开始时，先在运算符栈栈底压入一个表达式的结束符*#*\u003cbr\u003e\n计算机系统在处理表达式时，从左到右依次读出表达式中的各个符号（操作数或运算符），每读出一个符号后，根据运算规则做如下的处理。假如是操作数，则将其压入操作数栈，并依次读下一个符号。假如是运算符，则与运算符栈的栈顶运算符进行优先级比较，并做以以下处理\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e假如读出的运算符的优先级高于运算符栈栈顶运算符的优先级，则将其压入运算符栈，并依次读下一个符号\u003c/li\u003e\n\u003cli\u003e假如读出的运算符的优先级等于运算符栈栈顶运算符的优先级，说明左右括号相遇，只需将栈顶运算符退栈即可\u003c/li\u003e\n\u003cli\u003e#假如读出的运算符的优先级低于运算符栈栈顶运算符的优先级，则从操作数栈连续退出两个操作数，从运算符栈中退出一个运算符，然后做相应的运算，并将运算结果压入操作数栈\u003c/li\u003e\n\u003cli\u003e假如读出的是表达式结束符*#\u003cem\u003e，且运算符栈栈顶的运算符也为\u003c/em\u003e#*，则表达式处理结束，最后的表达式的计算结果在操作数栈的栈顶位置\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e表1 表达式3+4*2计算过程栈区变化表\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e序号\u003c/th\u003e\n\u003cth\u003e操作数栈\u003c/th\u003e\n\u003cth\u003e运算符栈\u003c/th\u003e\n\u003cth\u003e尚待读入的表达式\u003c/th\u003e\n\u003cth\u003e注释\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e#\u003c/td\u003e\n\u003ctd\u003e3+4*2#\u003c/td\u003e\n\u003ctd\u003e初始状态\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e#\u003c/td\u003e\n\u003ctd\u003e+4*2#\u003c/td\u003e\n\u003ctd\u003e读入3\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e#+\u003c/td\u003e\n\u003ctd\u003e4*2#\u003c/td\u003e\n\u003ctd\u003e读入+\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e4\u003c/td\u003e\n\u003ctd\u003e3,4\u003c/td\u003e\n\u003ctd\u003e#+\u003c/td\u003e\n\u003ctd\u003e*2#\u003c/td\u003e\n\u003ctd\u003e读入4\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e3,4\u003c/td\u003e\n\u003ctd\u003e#+*\u003c/td\u003e\n\u003ctd\u003e2#\u003c/td\u003e\n\u003ctd\u003e读入2#\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e6\u003c/td\u003e\n\u003ctd\u003e3,4，2\u003c/td\u003e\n\u003ctd\u003e#+*\u003c/td\u003e\n\u003ctd\u003e#\u003c/td\u003e\n\u003ctd\u003e读入2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e7\u003c/td\u003e\n\u003ctd\u003e3， 8\u003c/td\u003e\n\u003ctd\u003e#+\u003c/td\u003e\n\u003ctd\u003e#\u003c/td\u003e\n\u003ctd\u003e计算4*2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e8\u003c/td\u003e\n\u003ctd\u003e11\u003c/td\u003e\n\u003ctd\u003e#\u003c/td\u003e\n\u003ctd\u003e#\u003c/td\u003e\n\u003ctd\u003e计算3+8\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e9\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e结束\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e栈与递归过程\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e栈的一个重要应用是在程序设计语言中实现递归过程。递归即在定义自身的同时又出现了对自身的调用。如果一个函数在其定义体内直接调用自己，则称其为“直接递归函数”。如果一个函数经过一系列中间调用语句，通过其他函数间接调用自己，则称其为“间接递函数归”\u003c/p\u003e\n\u003cp\u003e有很多数学函数是递归定义的，如阶乘函数的定义\u003cbr\u003e\n\u003cspan class=\"katex-display\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo stretchy=\"false\"\u003e!\u003c/mo\u003e\u003cmo\u003e=\u003c/mo\u003e\u003cmrow\u003e\u003cmo fence=\"true\"\u003e{\u003c/mo\u003e\u003cmtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"\u003e\u003cmtr\u003e\u003cmtd\u003e\u003cmstyle scriptlevel=\"0\" displaystyle=\"false\"\u003e\u003cmrow\u003e\u003cmn\u003e1\u003c/mn\u003e\u003cmspace width=\"2em\"\u003e\u003c/mspace\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e=\u003c/mo\u003e\u003cmn\u003e0\u003c/mn\u003e\u003c/mrow\u003e\u003c/mstyle\u003e\u003c/mtd\u003e\u003c/mtr\u003e\u003cmtr\u003e\u003cmtd\u003e\u003cmstyle scriptlevel=\"0\" displaystyle=\"false\"\u003e\u003cmrow\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e×\u003c/mo\u003e\u003cmo stretchy=\"false\"\u003e(\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e−\u003c/mo\u003e\u003cmn\u003e1\u003c/mn\u003e\u003cmo stretchy=\"false\"\u003e)\u003c/mo\u003e\u003cmspace width=\"2em\"\u003e\u003c/mspace\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo mathvariant=\"normal\"\u003e≠\u003c/mo\u003e\u003cmn\u003e0\u003c/mn\u003e\u003c/mrow\u003e\u003c/mstyle\u003e\u003c/mtd\u003e\u003c/mtr\u003e\u003c/mtable\u003e\u003c/mrow\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003en! = \\begin{cases}\n1 \\qquad n = 0 \\\\\nn \\times (n - 1) \\qquad n \\neq 0\n\\end{cases}\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6944em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mclose\"\u003e!\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"minner\"\u003e\u003cspan class=\"mopen delimcenter\" style=\"top:0em;\"\u003e\u003cspan class=\"delimsizing size4\"\u003e{\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mtable\"\u003e\u003cspan class=\"col-align-l\"\u003e\u003cspan class=\"vlist-t vlist-t2\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:1.69em;\"\u003e\u003cspan style=\"top:-3.69em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:3.008em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:2em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e0\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"top:-2.25em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:3.008em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e×\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e−\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:2em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e\u003cspan class=\"mrel\"\u003e\u003cspan class=\"mord vbox\"\u003e\u003cspan class=\"thinbox\"\u003e\u003cspan class=\"rlap\"\u003e\u003cspan class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"\u003e\u003c/span\u003e\u003cspan class=\"inner\"\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mrel\"\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"fix\"\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e0\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-s\"\u003e​\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:1.19em;\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mclose nulldelimiter\"\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cpre data-role=\"codeBlock\" data-info=\"c#\" class=\"language-c# c#\"\u003e\u003ccode\u003elong fact(int n)\n{\n    if(n == 0)\n    {\n        return 1;\n    } else {\n        return (n * fact(n -1));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e递归算法的设计步骤如下\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将规模较大的原问题分解为一个或多个规模更小，但具有类似于原问题特性的子问题，即较大的问题递归地用较小的子问题来描述，解原问题的方法同样可用来解这些子问题\u003c/li\u003e\n\u003cli\u003e确定一个或多个无须分解，可直接求解的最小子问题（称为“递归的终止条件”）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e递归算法有两个基本的特征：递归归纳和递归终止。首先能将问题转化为比原问题规模小的同类问题，归纳出一般递推公式，故所处理的对象要有规律地递增或递减；当规模小到一定的程度应结束递归调用，逐层返回\u003c/p\u003e\n\u003ch2 id=\"队列\"\u003e队列 \u003c/h2\u003e\n\u003cp\u003e它只允许插入在表的一端进行，而删除在表的另一端进行，允许插入的一端叫队尾（rear），而允许删除的一端叫队头（front）。队列的插入操作通常称为“入队”或“进队”，而队列的删除操作则称为“出队”或“退队”;队”。当队列中无数据元素时，称为“空队列”。根据队列的定义可知，队头元素总是最先进队列，也总是最先出队列；队尾元素总是最后进队列，因而也是最后出队列。这种表是按照先进先出（first in first out FIFO）的原则组织数据的，因此，队列也被称为“先进先出”表\u003c/p\u003e\n\u003ch2 id=\"分治法\"\u003e分治法 \u003c/h2\u003e\n\u003cp\u003e在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单地直接求解，原问题的解即子问题的解的合并\u003c/p\u003e\n\u003cp\u003e任何一个可以用计算机求解的问题，其所需的计算时间都与规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少\u003c/p\u003e\n\u003cp\u003e分治法所能解决的问题一般具有以下几个特征。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e该问题的规模缩小到一定的程度就可以容易地解决。\u003c/li\u003e\n\u003cli\u003e该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。\u003c/li\u003e\n\u003cli\u003e利用该问题分解出的子问题的解可以合并为该问题的解。\u003c/li\u003e\n\u003cli\u003e该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e分治法在每一层递归上都有如下三个步骤\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e分解：将原问题分解为若干个规模较小、相互独立，且与原问题形式相同的子问题。\u003c/li\u003e\n\u003cli\u003e解决：若子问题规模较小且容易被解决则直接解，否则递归地解各个子问题。\u003c/li\u003e\n\u003cli\u003e合并：将各个子问题的解合并为原问题的解。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca href=\"https://ebook.hep.com.cn/index.html#/reader?bookId=1061913534566236161\"\u003e原文地址\u003c/a\u003e\u003c/p\u003e\n\n      \u003c/div\u003e\n      \u003cdiv class=\"md-sidebar-toc\"\u003e\n\u003cdiv class=\"md-toc\"\u003e\n\u003cdetails style=\"padding:0;;padding-left:0px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#栈和队列\" class=\"md-toc-link\"\u003e\u003cp\u003e栈和队列\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdetails style=\"padding:0;;padding-left:24px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#栈\" class=\"md-toc-link\"\u003e\u003cp\u003e栈\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#多栈共享邻接空间\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e多栈共享邻接空间\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/details\u003e\n    \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#应用\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e应用\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#队列\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e队列\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#分治法\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e分治法\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/details\u003e\n    \n\u003c/div\u003e\n\u003c/div\u003e\n      \u003ca id=\"sidebar-toc-btn\"\u003e≡\u003c/a\u003e\n    \n    \n    \n    \n    \n    \n\u003cscript\u003e\n\nvar sidebarTOCBtn = document.getElementById('sidebar-toc-btn')\nsidebarTOCBtn.addEventListener('click', function(event) {\n  event.stopPropagation()\n  if (document.body.hasAttribute('html-show-sidebar-toc')) {\n    document.body.removeAttribute('html-show-sidebar-toc')\n  } else {\n    document.body.setAttribute('html-show-sidebar-toc', true)\n  }\n})\n\u003c/script\u003e\n      \n  \n    "},"title":"03栈和队列"},"__N_SSG":true},"page":"/chapter/[chapterId]","query":{"chapterId":"c536b6e5a0f143f4743ce2c779f9f0a7_fd0020c886adebfe144cfb0990e8cf39"},"buildId":"VY6YhJCpFetLWoMetjDAA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>