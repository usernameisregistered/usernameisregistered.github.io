<!DOCTYPE html><html lang="zh-cn"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head=""></title><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/static/css/d3487b3baa5df050.css" as="style"/><link rel="stylesheet" href="/static/css/d3487b3baa5df050.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/static/chunks/webpack-a9de24c27879d5d9.js" defer=""></script><script src="/static/chunks/framework-a4ddb9b21624b39b.js" defer=""></script><script src="/static/chunks/main-40e151073ba9b914.js" defer=""></script><script src="/static/chunks/pages/_app-c801a419d8851d78.js" defer=""></script><script src="/static/chunks/121-ea166289b6b9b64f.js" defer=""></script><script src="/static/chunks/278-09ee5e026e1c614e.js" defer=""></script><script src="/static/chunks/pages/chapter/%5BchapterId%5D-925a7a08422d18ae.js" defer=""></script><script src="/static/delumengma/_buildManifest.js" defer=""></script><script src="/static/delumengma/_ssgManifest.js" defer=""></script></head><body data-for="html-export" class="antialiased"><div id="__next"><div class="w-screen flex flex-col h-screen"><header class="flex flex-grow-0 justify-between p-4 border-b border-neutral-200"><a class="flex items-center text-2xl text-neutral-700 cursor-pointer" href="/"><img alt="得鹿梦鱼" loading="lazy" width="40" height="40" decoding="async" data-nimg="1" style="color:transparent" src="/logo.svg"/><span class="text-4 ml-4">得鹿梦鱼</span></a><div class="right flex items-center cursor-pointer"><a class="mr-2  text-md " href="/classify">知识库</a><a class="mr-2  text-md " href="/frontend">前端技能树</a><a class="mr-2  text-md " href="/question">面试题</a><a class="mr-2  text-md " href="/study">学习资料</a><a class="mr-2  text-md " href="/about">关于本人</a></div></header><div class="w-screen flex flex-1"><aside class="basis-2/12 border-r border-gray-300 h-full overflow-hidden"><div class="text-md font-bold text-gray-700 m-4">JavaScript引擎并行化研究与设计</div><div dir="ltr" class="relative overflow-hidden scroll--chapter-height" style="position:relative;--radix-scroll-area-corner-width:0px;--radix-scroll-area-corner-height:0px"><style>[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}</style><div data-radix-scroll-area-viewport="" class="h-full w-full rounded-[inherit]" style="overflow-x:hidden;overflow-y:hidden"><div style="min-width:100%;display:table"><a class="text-md text-gray-600 block mx-4 mb-2 cursor-pointer overflow-hidden text-ellipsis whitespace-nowrap hover:text-sky-300" href="/chapter/10027_100000">引擎优化技术</a><a class="text-md text-sky-300 block mx-4 mb-2 cursor-pointer overflow-hidden text-ellipsis whitespace-nowrap hover:text-sky-300" href="/chapter/10027_100001">引擎编译缓存区管理策略</a><a class="text-md text-gray-600 block mx-4 mb-2 cursor-pointer overflow-hidden text-ellipsis whitespace-nowrap hover:text-sky-300" href="/chapter/10027_100002">引擎并行处理架构的设计与实现</a></div></div></div></aside><section class="basis-10/12 flex flex-col p-1"><div class="flex-1"><div dir="ltr" class="relative overflow-hidden scroll-content-height" style="position:relative;--radix-scroll-area-corner-width:0px;--radix-scroll-area-corner-height:0px"><style>[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}</style><div data-radix-scroll-area-viewport="" class="h-full w-full rounded-[inherit]" style="overflow-x:hidden;overflow-y:hidden"><div style="min-width:100%;display:table"><div id="markdown-container">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="javascript引擎编译缓存区管理策略">JavaScript引擎编译缓存区管理策略 </h1>
<blockquote>
<p>在直接影响JavaScript引擎执行性能方面，即时编译执行和解释执行之间一个最重要的区别就是即时编译执行中JavaScript引擎设置了专门的编译缓存区来存储即时编译生成的对应平台的机器码，JavaScript引擎中的编译缓存区与电脑硬件上面的缓存不同，他是JavaScript引擎在内存中开辟的一块用于为即时编译服务的存储区域，当JavaScript引擎在执行过程总需要再次执行同一段JavaScript代码时，则直接从编译缓存区中查找，将响应的对应平台的机器码拷贝到执行缓冲池中进行执行，这样减少了JavaScript代码中的重新编译频率，提高了代码重用率，减少了编译开销。</p>
</blockquote>
<h2 id="编译缓存区现有管理策略">编译缓存区现有管理策略 </h2>
<blockquote>
<p>JavaScript引擎在对JavaScript代码进行即时编译时，主要工作包括了对JavaScript的编译和对生成的对应平台的机器码的链接，这些都是在编译缓存区中进行的，JavaScript引擎在即时编译时需要将编译生成的对应平台的机器码按照地址顺序连续的存储到编译缓存中，以确保生成的对应平台的机器码在执行时在物理地址上是连续的</p>
</blockquote>
<p>由于JavaScript引擎对JavaScript代码即时编译生成的机器码无法事先预测大小，因此无法准确的确定编译缓存区的大小，如果编译缓存区的大小在初始化时设置的过大虽然会保证生成的机器码能够完全存入编译器缓存中，但是对于嵌入式设备有限的内存空间则会造成存储空间的资源紧张。而如果编译缓存区的大小设置的过小又会无法保证编译生成的机器码能够完整的存入缓存区中，因此JavaScript引擎现有的编译缓存区的管理策略是：首先，JavaScript引擎将编译缓存区的初始大小设置为一个M的阈值，随着JavaScript引擎对JavaScript代码即时编译生成的机器码存入编译缓存中，编译缓存区的空间减少，当机器码在存入编译缓存区之间空闲缓冲区的空间小于待存入的机器码的大小时，JavaScript引擎会重新开辟一个1.5倍大小与一个M的编译缓冲区，将新阈值设置为原先阈值的1.5倍。接着javas引擎会把原先编译缓存区中存储的机器码完整的拷贝到新开辟的编译缓存区中，同时释放原有的编译缓存区空间，随着即时编译过程的进行，如果新开辟的存储空间无法再次存入生成的机器码的时候，则需要再次使用该方式开辟新的编译缓存区空间，如下图</p>
<p><img src="/assets/100000142" alt="现有编译缓存区管理策略"></p>
<p>上述的管理策略虽然能够解决编译缓存区初始化设定大小和编译缓存区存储空间不够导致无法存入生成的机器码的问题，但是也存在一下问题：该管理策略中含有JavaScript引擎对新的存储空间的申请和开辟工作，大量机器码的拷贝工作以及原有存储空间的释放工作，这些执行操作会造成大量执行开销，导致嵌入式设备内存紧张，如果降低阈值的大小，开辟空间、拷贝数据和释放原空间的次数将会增加，浏览器在加载网页时的CPU占用率也将大大的增加，甚至出现“卡死”现象，编译缓存区是JavaScript引擎在即时编译模式下生成机器码和执行机器码的重要组成部分，该管理策略会严重降低JavaScript引擎在即时编译模式的执行效率，成为JavaScript引擎执行性能的瓶颈。因此需要对现有的JavaScript引擎的编译缓存器的管理策略进行改进，提高JavaScript引擎的执行效率</p>
<h2 id="编译缓存区的管理策略改进和实现">编译缓存区的管理策略改进和实现 </h2>
<p>为了解决上述问题，在改进的编译缓存区中，JavaScript引擎对编译缓存区空间离散的管理方式，将编译缓存区初始化大小设置为一个基本单元缓存块的大小，其管理模式为：</p>
<blockquote>
<p>JavaScript引擎会在JavaScript引擎启动时预设编译缓存区的大小为一个固定值，而当JavaScript引擎将编译生成的某段机器码存入到编译缓存区时，JavaScript引擎仅仅只分配一块基本单元缓存块对机器码进行存储，并通过链表进行连接，如果存入空间不够JavaScript引擎再次分配一块基本单元缓存块用于存储某段机器码剩余的部分，这种存储空间分配方式即消除了嵌入式设备的内存空间的压力，也保证了存储空间的动态增长能够满足即时编译生成的机器码的存储，同时也提高了JavaScript引擎对编译编译缓冲区的管理效率</p>
</blockquote>
<h2 id="编译缓存区数据结构改进与设计">编译缓存区数据结构改进与设计 </h2>
<h3 id="编译缓存区数据结构分析">编译缓存区数据结构分析 </h3>
<p>JavaScript引擎现有的编译缓存区的数据结构是数组结构，查找效率较低，机器码的存储开销也比较大，因此可以使用其他的数据结构来代替数组结构，也包括了哈希表。红黑树等，以减少JavaScript引擎即时编译生成的机器码存储开销，提高JavaScript引擎在执行时在编译缓存区中查找需要执行的机器码的效率</p>
<h3 id="编译缓存区数据结构的改进与设计">编译缓存区数据结构的改进与设计 </h3>
<p>由于编译缓存区只是JavaScript引擎生成的机器码的临时存放区域，JavaScript引擎在执行JavaScript代码是都会将相应的机器码从编译缓冲区拷贝到代码执行池中进行执行，因此只需要保证代码池中的机器码是连续的物理地址，就能使得JavaScript引擎在JavaScript代码时连续的，对于编译缓存区中机器码的存放则不需要保证在物理地址上的连续</p>
<p>因此对于编译缓存区的存储空间采用的是多个离散的基本单元缓存块的方式，可以采取哈希表的数据结构对不同的基本单元缓存块进行管理，而对于哈希表而言，哈希表在输入的数据集随机时容易出现大规模的冲突，虽然有很多有效的哈希函数，但是对于随机输入的数据集时，大规模的冲突还是不可避免的，出现最差的情况</p>
<p>在JavaScript引擎中，由于编译缓存区是一整块连续的物理地址空间，而基本单元缓存块的数量并不会是很多，因此基本单元缓存块的地址可以呈现均匀分布的状态，哈希表就不会出现大规模的冲突状况，而基本单元缓存块之间则用双链表进行链接，保证JavaScript引擎在执行JavaScript代码时能够寻找查找到对应的机器码</p>
<p>由于编译缓存区的基本单元 缓存块是链表结构，因此JavaScript引擎对需要执行的 JavaScript代码所对应的机器码的查找时间复杂度是O(n)。为了提高查找效率，因此可以通过哈希表对编译缓存区的基本单元缓存块进行管理。每次新分配的存入了机器码基本单元缓存块的地址都会更新到哈希表中，而清空一个或多个基本编译缓存块时则会从哈希表中移除。这样JavaScript引擎在查找需要执行的JavaScript代码所对应的机器码时直接通过哈希表进行查找，获取对应的机器码在编译缓存区中的位置，而查找的时间复杂度为O(1)大大降低了查找开销</p>
<p><img src="/assets/100000143" alt="基本单元缓存块的管理方式"></p>
<p>CacheHandler结构作为这些独立的基本单元缓存块的管理者，是编译缓存区和的机器码执行的接口。CacheHandler结构使得编译缓存区的管理机制透明，同时与JavaScript引擎现有的编译缓存区的接口一致。JavaScript引擎通过CacheHandler结构提供的接口，就可以实现对即时编译生成的机器码的存储、链接以及将机器码拷贝代码执行池中</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">CacheHandler</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token keyword keyword-static">static</span> CacheHandler<span class="token operator">*</span> <span class="token function">getCacheHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">registernativeCode</span><span class="token punctuation">(</span>NativeCode<span class="token operator">*</span> nativeCode<span class="token punctuation">,</span> size_t<span class="token operator">&amp;</span> nativekey<span class="token punctuation">)</span><span class="token punctuation">;</span>
        NativeCode<span class="token operator">*</span> <span class="token function">getNativeCode</span><span class="token punctuation">(</span>size_t nativekey<span class="token punctuation">)</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token function">CacheHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">~</span><span class="token function">CacheHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-static">static</span> CacheHandler<span class="token operator">*</span> m_cachehandler<span class="token punctuation">;</span>
        size_t m_currentNativeCodeKey<span class="token punctuation">;</span>
        Vector<span class="token operator">&lt;</span>NativeCode<span class="token operator">*</span><span class="token operator">&gt;</span> m_NativeCodePool<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="编译缓存区替换策略的设计">编译缓存区替换策略的设计 </h2>
<blockquote>
<p>在JavaScript代码的执行过程中JavaScript引擎在执行过程中如果遇到已被编译过的JavaScript代码时，JavaScript引擎会从编译缓存区中查找相应的机器码，将相应的机器码拷贝到代码执行池中，而部分JavaScript代码需要频繁执行，而某些JavaScript代码则不会再次执行。因此可以将这一部分的机器码在编译缓存区中移除，而只需在编译缓存区中保留需要频繁执行的机器码，从而使得编译缓存区的大小固定在一定范围内，减少嵌入式设备的内存压力35。对此，本文根据上文所进行的编译缓存区的存储空间的管理方式和数据结构的改进设计两种编译缓存区的替换策略</p>
</blockquote>
<h3 id="基于计数器思想的替换策略">基于计数器思想的替换策略 </h3>
<p>每个基本单元缓存块1到缓存块n中每个都有一个计数器，当某段机器码需要被再次执行时，存储改机器码的一个或者多个基本单元缓存块的计数都加1，如果有即时编译生成的机器码存入编译缓存区时编译缓存区的大小等于JavaScript引擎在启动时所设的固定值时，则需要根据计算器的大小，在将待存入的机器码直接存入到计算取最小的一个或者多个基本单元缓存块中，同时将该基本单元缓存块的计数器置为零</p>
<h3 id="基于lru算法的替换策略">基于LRU算法的替换策略 </h3>
<p>由于JavaScript引擎将编译缓存区中的各个基本编译缓存块通过链表进行连接，因此可以将各个基本编译缓存块通过双向链表连接起来，当待存入的机器码需要新分配基本编译缓存块存储时，则将新分配的基本编译缓存块置于链表的尾部，当JavaScript引擎需要再次执行某段JavaScript代码时，JavaScript引擎会在查找到所对应的机器吗后将其拷贝到代码池中执行，同时将对应的机器码所在的一个或者多个基本编译缓存块整体迁移到链表的尾部，这样JavaScript代码在经过多次执行后，最近被频繁执行的JavaScript代码对对应的机器码所在的基本编译块向链表表尾移动，执行次数很少或者没有被执行的JavaScript代码所对应的机器码所在的基本编译缓冲块则会向表头移动，当编译缓存区空间等于JavaScript引擎在启动时设定的阈值时，JavaScript引擎则可以将待存入的机器码直接存入到表头中，</p>

      </div>
      <div class="md-sidebar-toc">
<div class="md-toc">
<details style="padding:0;;padding-left:0px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#javascript引擎编译缓存区管理策略" class="md-toc-link"><p>JavaScript引擎编译缓存区管理策略</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#编译缓存区现有管理策略" class="md-toc-link">
            <p>编译缓存区现有管理策略</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#编译缓存区的管理策略改进和实现" class="md-toc-link">
            <p>编译缓存区的管理策略改进和实现</p>

          </a></div><details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#编译缓存区数据结构改进与设计" class="md-toc-link"><p>编译缓存区数据结构改进与设计</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#编译缓存区数据结构分析" class="md-toc-link">
            <p>编译缓存区数据结构分析</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#编译缓存区数据结构的改进与设计" class="md-toc-link">
            <p>编译缓存区数据结构的改进与设计</p>

          </a></div>
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#编译缓存区替换策略的设计" class="md-toc-link"><p>编译缓存区替换策略的设计</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#基于计数器思想的替换策略" class="md-toc-link">
            <p>基于计数器思想的替换策略</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#基于lru算法的替换策略" class="md-toc-link">
            <p>基于LRU算法的替换策略</p>

          </a></div>
        </div>
      </details>
    
        </div>
      </details>
    
</div>
</div>
      <a id="sidebar-toc-btn">≡</a>
    
    
    
    
    
    
<script>

var sidebarTOCBtn = document.getElementById('sidebar-toc-btn')
sidebarTOCBtn.addEventListener('click', function(event) {
  event.stopPropagation()
  if (document.body.hasAttribute('html-show-sidebar-toc')) {
    document.body.removeAttribute('html-show-sidebar-toc')
  } else {
    document.body.setAttribute('html-show-sidebar-toc', true)
  }
})
</script>
      
  
    </div></div></div></div></div><div class="flex justify-between"><div class="visible border min-w-60 h-10 px-4 leading-10 border-gray-300 text-center cursor-pointer rounded-md hover:text-sky-300">引擎优化技术</div><div class="visible border min-w-60 px-4  h-10 leading-10 border-gray-300 text-center cursor-pointer rounded-md hover:text-sky-300">引擎并行处理架构的设计与实现</div></div></section></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"bookInfo":{"id":"10027","name":"JavaScript引擎并行化研究与设计","fullPath":"F:\\passerby\\web\\JavaScript引擎并行化研究与设计","chapterList":[{"id":"10027_100000","type":"chapter","name":"引擎优化技术","fullPath":"F:\\passerby\\web\\JavaScript引擎并行化研究与设计\\01引擎优化技术.md","url":"/chapter/10027_100000","content":"\n    \n    \n      \u003cdiv class=\"crossnote markdown-preview  \"\u003e\n      \n\u003ch1 id=\"javascript引擎优化技术\"\u003eJavaScript引擎优化技术 \u003c/h1\u003e\n\u003ch2 id=\"javascript语言\"\u003eJavaScript语言 \u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJavaScript语言是一个实实在在的标准的脚本语言，作用于网络客户端的编程上，主要用于网页中的事件 触发、密集计算和 与用户之间的互动操作。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"虚拟机优化技术\"\u003e虚拟机优化技术 \u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e一般来说脚本语言例如Python、Ruby、JavaScript 都是动态语言，动态语言的特性就是只有在运行时才能确定代码对象的类型，因此一般都是通过解释器来进行执行。动态语言在执行时需要有对应平台的解释器，这样的好处在于由于解释器速度很快，执行速度也会很快。而编译方式则需要在对代码编译完生成对应平台的可执行目标代码后才执行，增加了等待时间。但是代码中如果出现了需要频繁执行的部分，解释器由于生产对应平台的可执行目标代码，则需要不断的边翻译边执行，同时针对不同指令集的平台又需要不同的解释器。而编译方式可以重复利用生成的可执行目标代码，提高执行效率。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e而为了提高动态语言的执行效率，使其能够在不同系统、不同架构的平台上都能运行，就必须使得动态语言具有平台的独立性。程序代码能够在不同系统、不同架构的计算机平台上运行，不受其限制。因此动态语言都普遍采取虚拟机技术。虚拟机技术对动态语言的代码编译生成字节码，字节码是一种与具体平台的机器指令集无关的指令集合。字节码通过虚拟机的解释，生成所对应平台的可执行目标代码，就能够在相应的平台上面运行。而可执行目标代码则在虚拟机中存\u003cbr\u003e\n储，当可执行目标代码需要再次执行时，则可以直接从虚拟机中调取进行执行\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"javascript-引擎架构\"\u003eJavaScript 引擎架构 \u003c/h2\u003e\n\u003cp\u003e本文中所采用的的JavaScript引擎为webkit浏览器中所使用的\u003cstrong\u003eSquirrelFish Extreme(SFX)\u003c/strong\u003e,其架构大概可以分为编译模块、编译器控制模块、机器码缓存区和执行模块，如下图所示\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000136\" alt=\"引擎结构图\"\u003e\u003c/p\u003e\n\u003cp\u003eSFX引擎采用即时编译模式执行JS代码，引擎将JS代码编译成个字节码，编译模块将字节码编译成对应平台的可执行机器码后存入机器码缓存区中，执行模块再从缓存池中取出需要执行的机器码进行执行\u003c/p\u003e\n\u003cp\u003e在SFX引擎中，编译模块对字节码进行编译的最小单位是函数块，当某个函数被首次调用执行时，改函数将被编译为机器码存入缓存区中，之后该函数需要被再次调用时引擎则直接从缓存区中调用改函数的机器码，而其他的引擎如V8的执行过程是直接将JS代码编译成为对应平台的可执行机器码而没有翻译成字节码，TraceMonkey JavaScript 引擎对字节码进行编译的最小单元是 JavaScript引擎追踪判定的热点路径而非函数块\u003c/p\u003e\n\u003ch2 id=\"字节码的优化技术\"\u003e字节码的优化技术 \u003c/h2\u003e\n\u003cp\u003eJS引擎中定义了一个包含了109种字节码指令的指令集，该指令集的存取采用的是基于寄存器机制而非Java虚拟器的基于栈的机制，该指令集中的多数指令包括了js引擎中重要的执行指令语义，包括创建新的对象、读写寄存器、执行算术运行、写入对象属性、创造分支和循环结构、调用在js引擎自定义的函数和管理函数调用的上下文环境等功能。SFX引擎的字节码即时编译的流程是在低昂CTI专用函数来处理字节码指令后，才编译为机器码，而没有直接编译为机器码。在这109个指令中，其中有51个指令必须被CTI函数处理后才能够被编译，另外有40个指令只有在该指令运行直接被编译为机器码时才不需要被CTI函数处理，而剩余的18个精简指令将被直接被编译为机器码，而java虚拟机能够将绝大多数的字节码指令直接编译为机器码。因此js引擎的即时编译的性能低于同样使用了即时编译模式的java虚拟机\u003c/p\u003e\n\u003cp\u003e影响js引擎即时编译性能的因素还包括生成的机器码的代码质量。JS引擎在即时编译模式下降字节码编译为机器码时，必须调用宏汇编编译器提供的预定义的macro assembler函数和字节码通信，下图展示了将字节码指令op_bitxor编译为ARM汇编指令机器码的emit_op_bitxor()宏汇编函数的主要代码\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000137\" alt=\"宏汇编编译函数流程\"\u003e\u003c/p\u003e\n\u003cp\u003e在即时编译模式下必须调用emit_op_bitxor()宏汇编编译函数对字节码指令op_bitxor处理，然后在调用其他的宏汇编编译器来生成对应平台的机器码。首先js引擎通过调用宏汇编编译函数emitGetVirtualRegisters()生成将2个参数从js引擎的物理寄存器中转存到虚拟寄存器中的机器码，然后调用宏汇编编译函数xorPtr()用于生成ARM上的按位XOR汇编指令机器码，然后调用宏汇编编译函数emitPutVirtualRegister()生成将虚拟寄存器中的结果存入物理寄存器文件中的机器码，由于虚拟寄存器是去全局映射于物理寄存器，因此字节码指令转为ARM机器码如下图所示\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000138\" alt=\"字节码指令转换为机器码\"\u003e\u003c/p\u003e\n\u003cp\u003e尽管这种基于宏汇编编译器的机器码生成模式能够加速对应平台的即时编译生成的机器码的重定位，但是这种模式下严重的限制了代码质量的优化，与java虚拟器的即时编码模式相比，js引擎中每一个字节码都是独立的进行编译，导致编译生成的机器码的数据结构类型的与解释模式下的一样，无法生成高质量的机器代码，对于每个字节码。宏汇编便器决定了字节码指令生成的机器码的顺序，因此机器码也无法进行优化，此外，虚拟寄存器无需使用独立的寄存器定位机制实现全局映射物理寄存器，多数复杂的字节码指令在即时编译模式下被编译时是直接调用CTI函数，因此所生成的机器码质量低于在JAVA虚拟器中以即时编译所实现的机器码的质量\u003c/p\u003e\n\u003ch2 id=\"预编译方式的优化技术\"\u003e预编译方式的优化技术 \u003c/h2\u003e\n\u003cp\u003e预编译指的是在JavaScript引擎在执行JavaScript代码之前，预先将JavaScript代码所生成的字节码编译成对应平台的可执行的本地代码，并且存入本地内存中，之后JavaScript引擎均在对应平台上对本地代码进行执行，不再重新编译JavaScript代码，\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000139\" alt=\"预编译工作流程\"\u003e\u003c/p\u003e\n\u003ch3 id=\"优势\"\u003e优势 \u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e大幅度缩短了js代码的加载启动时间\u003c/li\u003e\n\u003cli\u003e只对js代码进行一次编译，减少了js引擎在执行js代码时的编译开销\u003c/li\u003e\n\u003cli\u003e可以在编译过程中对js代码进行与静态编译相类似的复杂的代码优化，提高质量\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"劣势\"\u003e劣势 \u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eJavaScript 引擎需要大量的内存空间来保存编译之后生成的本地代码，而本地代码由于进行了复杂的代码优化，其会比原始的字节码占用更大量的JavaScript 引擎的存储空间；\u003c/li\u003e\n\u003cli\u003e编译之后生成的本地代码不具备跨平台的可移植性\u003c/li\u003e\n\u003cli\u003e由于JavaScript 语言自身所具有的动态性，如动态类的类型装载，垃圾回收处理、异常行为检测等，都会使得预编译方式的优化技术实现起来较为困难\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"即时编译方式的优化技术\"\u003e即时编译方式的优化技术 \u003c/h2\u003e\n\u003cp\u003e即时编译指的是JavaScript 引擎在执行JavaScript 代码之前，通常以字节码中的函数块为基本的编译单元，首先将JavaScript 代码生成的字节码编译成对应平台的机器码，存入相应的编译缓存区中。当该段机器码需要再次进行执行时，则可以从编译缓存区中再次取出这段机器码进行执行，避免了再次编译的编译开销，减少了JavaScript 引擎等待编译的时间。在用户关闭浏览器之后，编译生成的机器码的存储空间将被释放。当用户再次打开浏览器执行相同的JavaScript 代码时，JavaScript 引擎不能立即执行，而需要再次即时编译\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000140\" alt=\"即时编译工作流程\"\u003e\u003c/p\u003e\n\u003cp\u003e与预编译方式的优化技术相比较，即时编译方式的优化技术具有以下的优势\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e没有必要长期保存编译生成的对应平台的机器码，节省了JavaScript的静态解释执行的存储空间\u003c/li\u003e\n\u003cli\u003e由于即时编译方式是在JavaScript 代码执行时进行即时编译，所以实现JavaScript语言自有的动态特征相对而言比较容易\u003c/li\u003e\n\u003cli\u003eJavaScript 引擎每次运行时都会对JavaScript 代码再次进行编译，不会影响JavaScript代码生成的字节码的可移植性与跨平台性\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e与预编译方式的优化技术相比较，即时编译方式的优化技术具有以下的劣势\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e即时编译需要占用JavaScript 引擎的运行时间，编译开销过大，从而导致JavaScript代码的执行时间过长\u003c/li\u003e\n\u003cli\u003e对字节码即时编译所生成的对应平台的机器码会导致JavaScript引擎的内存空间的紧张\u003c/li\u003e\n\u003cli\u003e由于即时编译需要在JavaScript代码执行前就要完成，因此许多用于解释执行过程中对代码的复杂优化方式都无法使用 导致无法提升机器码的代码质量；\u003c/li\u003e\n\u003cli\u003e由于即时编译方式中通常以字节码中的函数块为基本的编译单元要做到对字节码进行全局性的优化很困难\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"javascript-引擎中其他常用的优化技术\"\u003eJavaScript 引擎中其他常用的优化技术 \u003c/h2\u003e\n\u003ch3 id=\"多态内联缓存\"\u003e多态内联缓存 \u003c/h3\u003e\n\u003cp\u003e由于JavaScript语言是基于原型prototype based的语言，在执行过程中有对对象属性的动态访问，因此JavaScript引擎的执行性能也取决于如何更好的实现对JavaScript代码对对象属性的动态访问。多态内联缓存目前应用在WebKit小组的SquirrelFish Extreme JavaScript引擎中。多态内联缓存对通过属性记号在哈希表中查询进行了改进，在首次命中属性后，对对象的结构编号合属性在哈希表中的位置进行缓存，当再次访问该属性时则直接从缓存直接读取，提高了属性的命中率\u003c/p\u003e\n\u003ch3 id=\"上下文链接的即时编译\"\u003e上下文链接的即时编译 \u003c/h3\u003e\n\u003cp\u003e针对JavaScript 代码中出现的判断选择分支代码，将相应的分支代码进行判断，只对判断选择分支中的一项进行即时编译，编译生成不含有分支的机器码。这样能够使得JavaScript引擎在执行时减少对JavaScript代码中判断选择分支的判断开销。同时将JavaScript代码中复杂的执行设置为方法调用，将一些简单的JavaScript代码和一些常用的JavaScript代码内嵌到JavaScript 引擎的内核中，提升JavaScript引擎的执行速度\u003c/p\u003e\n\u003ch3 id=\"直接产生机器码\"\u003e直接产生机器码 \u003c/h3\u003e\n\u003cp\u003e该技术使用在Google 的Chrome浏览器的V8 JavaScript引擎中。 V8JavaScript引擎并没有将 JavaScript代码中首先转换为字节码，然后再将其即时编译为对应平台的机器码。而是将JavaScript 代码进行优化，直接将其编译为对应平台的机器码加以执行。由于V8JavaScript引擎中没有将JavaScript代码转换为字节码的中间步骤，因此JavaScript代码能够得到很快的执行。然而，由于其是直接将JavaScript代码转换为对应平台的机器码，因此缺乏转换成字节码所带来的可移植性和字节码优化性。\u003c/p\u003e\n\u003ch3 id=\"trace-技术\"\u003eTrace 技术 \u003c/h3\u003e\n\u003cp\u003eTrace技术主要运用在Mozilla的Firefox浏览的Monkey系列JavaScript引擎中。在JavaScript引擎执行JavaScript代码时，JavaScript代码中可能会出现许多条件判断分支代码，而在JavaScript代码的运行过程中，其中的一个分支可能会长时间运行。因此Trace技术就是通过对其中运行时间较长的分支代码的追踪，形成一条热点路径，对热点路径即时编译，而其他代码则以解释的方式进行执行\u003c/p\u003e\n\u003ch3 id=\"垃圾回收技术\"\u003e垃圾回收技术 \u003c/h3\u003e\n\u003cp\u003e垃圾回收技术在Google的Chrome浏览器的V8JavaScript引擎中，使用了更加主动地垃圾回收策略，而其他的JavaScript引擎和一些动态语言比如Python、Ruby都是使用的时被动地垃圾回收策略。因为被动的垃圾回收策略的操作比较精简，但是主动地垃圾回收策略虽然比较复杂，但是却更加有优势。Java虚拟机的垃圾回收策略就是主动地垃圾回收\u003c/p\u003e\n\u003cp\u003e主动地垃圾回收策略是对JavaScript引擎中不再使用的存储空间主动地检测，并将其释放；而被动的垃圾回收策略则是对JavaScript引擎中的不再使用的存储空间并没有主动检测，而是只是当JavaScript引擎中的存储空间不足时才对不再使用的存储空间进行释放。主动地垃圾回收策略还通过实行使用了分解的垃圾回收策略使用轻量级加载在高等级的分解垃圾回收上加载垃圾回收，在低等级的垃圾回收上使用被动的垃圾回收策略，因为主动地垃圾回收策略要对执行的JavaScript代码中的对象进行移动，而在保守的垃圾回收策略中这种操作相当复杂。V8JavaScript引擎对于对象地址的移动没有使用句柄来对对象地址作出索引，而是根据地址的改变对对象对应的数据进行修改。虽然不使用句柄会造成操作开销的增加，但是由于没有使用索引操作，减少了查找开销。\u003c/p\u003e\n\u003ch3 id=\"循环不变式外移\"\u003e循环不变式外移 \u003c/h3\u003e\n\u003cp\u003e循环不变式是在JavaScript代码中的某个循环结构中，在执行过程中一直为原表达初始值的表达式，是一种JavaScript引擎对JavaScript代码的优化手段\u003c/p\u003e\n\u003cpre data-role=\"codeBlock\" data-info=\"javascript\" class=\"language-javascript javascript\"\u003e\u003ccode\u003e\u003cspan class=\"token keyword keyword-let\"\u003elet\u003c/span\u003e s \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword control-flow keyword-for\"\u003efor\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword keyword-var\"\u003evar\u003c/span\u003e m \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e m \u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"token number\"\u003e20\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e m\u003cspan class=\"token operator\"\u003e++\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword control-flow keyword-for\"\u003efor\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword keyword-var\"\u003evar\u003c/span\u003e n \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e n \u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"token number\"\u003e10\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e n\u003cspan class=\"token operator\"\u003e++\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n        s\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003en\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e m \u003cspan class=\"token operator\"\u003e/\u003c/span\u003e \u003cspan class=\"token number\"\u003e2\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如同上面的示例代码，内层循环中的表达式\u003ccode\u003e m / 2\u003c/code\u003e,在内层循环中一直保持不变，因此该行代码为循环不变式，因此可以优化为\u003c/p\u003e\n\u003cpre data-role=\"codeBlock\" data-info=\"javascript\" class=\"language-javascript javascript\"\u003e\u003ccode\u003e\u003cspan class=\"token keyword keyword-let\"\u003elet\u003c/span\u003e s \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword control-flow keyword-for\"\u003efor\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword keyword-var\"\u003evar\u003c/span\u003e m \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e m \u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"token number\"\u003e20\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e m\u003cspan class=\"token operator\"\u003e++\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword keyword-let\"\u003elet\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e m \u003cspan class=\"token operator\"\u003e/\u003c/span\u003e \u003cspan class=\"token number\"\u003e2\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token keyword control-flow keyword-for\"\u003efor\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword keyword-var\"\u003evar\u003c/span\u003e n \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e n \u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"token number\"\u003e10\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e n\u003cspan class=\"token operator\"\u003e++\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n        s\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003en\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e i\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e将循环不变式外移出其表达式值保持不变的循环，能够减少JavaScript引擎在执行代码的执行开销，提高循环代码的执行效率\u003c/p\u003e\n\u003ch3 id=\"基于寄存器的字节码指令集\"\u003e基于寄存器的字节码指令集 \u003c/h3\u003e\n\u003cp\u003eJavaScript引擎没有采用基于栈的字节码指令集，而是采用了基于寄存器的字节码指令集。由于JavaScript 引擎对JavaScript代码的执行速度是影响JavaScript引擎的性能的一个最关键性的因素，而寄存器的访问速度和查找效率要大大优于选择了基于寄存器的指令集\u003c/p\u003e\n\u003cp\u003eJavaScript引擎采用基于寄存器字节码指令集时，会在执行时启用虚拟寄存器映射到运行平台上的物理寄存器上。由于JavaScript 引擎中一些字节码指令需要经常被执行，比如JavaScript 引擎中的字节码指令顺序进行管理的程序计数器，因此为了能够更加快速的访问这些需要频繁执行的字节码指令，这些字节码指令都一般存放在运行平台的物理寄存器中。然而JavaScript 引擎所启用的虚拟寄存器的数量一般会比运行平台中的物理寄存器的数量要多，因此虚拟寄存器无法实现与物理寄存器的一一映射，导致JavaScript引擎执行效率的降低。因此JavaScript引擎\u003cbr\u003e\n将频繁执行的字节码指令放置到虚拟寄存器中存放\u003c/p\u003e\n\u003cp\u003e而使用基于栈的字节码指令集的JavaScript 引擎由于没有通用寄存器，能够比较好的对允许平台中的物理寄存器进行分配。这样基于栈的字节码指令集的JavaScript 引擎能够很好的在各个运行平台上进行移植。在使用基于栈的字节码指令集的JavaScript 引擎中，栈通过即时编译映射到运行平台的物理寄存器中，减少了字节码指令的查找开销\u003c/p\u003e\n\u003ch3 id=\"异常处理推迟\"\u003e异常处理推迟 \u003c/h3\u003e\n\u003cp\u003eJavaScript语言为代码中出现的错误处理提供了异常处理机制，以下面的JavaScript代码为例\u003c/p\u003e\n\u003cpre data-role=\"codeBlock\" data-info=\"javascript\" class=\"language-javascript javascript\"\u003e\u003ccode\u003e\u003cspan class=\"token keyword control-flow keyword-try\"\u003etry\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword control-flow keyword-for\"\u003efor\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword keyword-let\"\u003elet\u003c/span\u003e m \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e20\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e m \u003cspan class=\"token operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e m\u003cspan class=\"token operator\"\u003e--\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"token comment\"\u003e// 请假定0不能为除数是会报错的\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-let\"\u003elet\u003c/span\u003e n \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e100\u003c/span\u003e \u003cspan class=\"token operator\"\u003e/\u003c/span\u003e m\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e \u003cspan class=\"token keyword control-flow keyword-catch\"\u003ecatch\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ee\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// output error\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在以上的JavaScript代码中，在try块中的代码如果出现了访问到内核区域的现象，就会发生0不能为除数异常。那么这个异常将会被catch块中的异常处理代码捕获。在JavaScript引擎执行该段JavaScript代码的时候，并不会对其中的try/catch异常处理模块即时编译为对应平台的机器码，而是在该段JavaScript代码执行过程中出现了0不能为除数异常时才会对异常进行处理。这样做的主要原因在于在JavaScript代码的执行过程中，异常出现的情况往往很少发生，JavaScript引擎没有必有对try/catch异常处理模块进行编译而增加对应平台的机器码的大小，造成对缓存区的存储空间的压力\u003c/p\u003e\n\u003ch2 id=\"线程级推测技术\"\u003e线程级推测技术 \u003c/h2\u003e\n\u003cp\u003e线程级推测技术(Thread-Level Speculation，TLS)是一种能够动态对线性执行的程序进行并行性扩展的技术，其能够运用在硬件和软件环境下。线程级推测技术一个主要的方法就是将每个循环迭代方法分配给每个线程。通过线程级推测技术的进行并行扩展例子如下图所示。在一个串行执行的代码，代码段A、Sub和B是串行执行的。通过线程级推测技术的分析，Sub代码段能够和B并行执行，因此可将Sub代码段分离出来使用另一个处理器进行执行，但是也造成相应的执行开销。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000141\" alt=\"线程级推测技术案例\"\u003e\u003c/p\u003e\n\u003cp\u003e每个循环迭代都能够平均分配到每个处理器上面。但是由于会出现数据依赖性问题，会限制并行执行的循环迭代的数量。同时，嵌入式设备的内存限制和在JavaScript代码运行时JavaScript引擎对数据依赖性的检测开销都是需要考虑的问题。在两个连续的循环迭代中可能会出现三种类型的数据依赖：写后读、读后写和写后写。而线程级推测技术必须能够对这三种类型的数据依赖通过每个循环迭代对内存空间的读写的动态信息的检测在JavaScript代码的执行过程中能够探测出来。而线程级推测技术的最关键问题就是如何保证其所探测出来的数据依赖性能够精确的检查出来。一旦数据依赖冲突被检测出来，JavaScript引擎对JavaScript 代码的执行过程必须中断，同时需要将执行回滚到一个没有冲突的地方。因此，每个线程级推测技术都需要一个高效的回滚机制。而对于出现的数据依赖冲突造成的回滚，其回滚开销和内存的存储开销都是很高的，因此需要在线程级推测过程中尽量避免回滚发生的情况。一个关键的线程级推测技术的因素是对数据依赖冲突进行追踪和检测的数据结构。一般来说，如果需要更加精确的数据依赖冲突追踪，就需要更大的内存空间。而会对数据依赖冲突检测的精确性造成影响的因素则是线程级推测技术检测到的数据依赖冲突可能不是当前运行时出现的数据依赖冲突\u003c/p\u003e\n\u003ch2 id=\"river-trial的优化技术\"\u003eRiver Trial的优化技术 \u003c/h2\u003e\n\u003cp\u003eRiver Trail是英特尔 公司开发的一种 并行编程的扩展插件。用户通过River Trail对于网络应用进行编程时，使用方法现有的JavaScript编程规则。同时River Trail使用确定性并行数据结构对JavaScript进行扩展，该结构在运行时会被转换为底层硬件抽象层指令。通过利用多核处理器和向量处理指令，River Trail可以大幅提升执行速度。\u003c/p\u003e\n\n      \u003c/div\u003e\n      \u003cdiv class=\"md-sidebar-toc\"\u003e\n\u003cdiv class=\"md-toc\"\u003e\n\u003cdetails style=\"padding:0;;padding-left:0px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#javascript引擎优化技术\" class=\"md-toc-link\"\u003e\u003cp\u003eJavaScript引擎优化技术\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#javascript语言\" class=\"md-toc-link\"\u003e\n            \u003cp\u003eJavaScript语言\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#虚拟机优化技术\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e虚拟机优化技术\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#javascript-引擎架构\" class=\"md-toc-link\"\u003e\n            \u003cp\u003eJavaScript 引擎架构\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#字节码的优化技术\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e字节码的优化技术\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdetails style=\"padding:0;;padding-left:24px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#预编译方式的优化技术\" class=\"md-toc-link\"\u003e\u003cp\u003e预编译方式的优化技术\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#优势\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e优势\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#劣势\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e劣势\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/details\u003e\n    \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#即时编译方式的优化技术\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e即时编译方式的优化技术\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdetails style=\"padding:0;;padding-left:24px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#javascript-引擎中其他常用的优化技术\" class=\"md-toc-link\"\u003e\u003cp\u003eJavaScript 引擎中其他常用的优化技术\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#多态内联缓存\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e多态内联缓存\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#上下文链接的即时编译\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e上下文链接的即时编译\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#直接产生机器码\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e直接产生机器码\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#trace-技术\" class=\"md-toc-link\"\u003e\n            \u003cp\u003eTrace 技术\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#垃圾回收技术\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e垃圾回收技术\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#循环不变式外移\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e循环不变式外移\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#基于寄存器的字节码指令集\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e基于寄存器的字节码指令集\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#异常处理推迟\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e异常处理推迟\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/details\u003e\n    \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#线程级推测技术\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e线程级推测技术\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#river-trial的优化技术\" class=\"md-toc-link\"\u003e\n            \u003cp\u003eRiver Trial的优化技术\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/details\u003e\n    \n\u003c/div\u003e\n\u003c/div\u003e\n      \u003ca id=\"sidebar-toc-btn\"\u003e≡\u003c/a\u003e\n    \n    \n    \n    \n    \n    \n\u003cscript\u003e\n\nvar sidebarTOCBtn = document.getElementById('sidebar-toc-btn')\nsidebarTOCBtn.addEventListener('click', function(event) {\n  event.stopPropagation()\n  if (document.body.hasAttribute('html-show-sidebar-toc')) {\n    document.body.removeAttribute('html-show-sidebar-toc')\n  } else {\n    document.body.setAttribute('html-show-sidebar-toc', true)\n  }\n})\n\u003c/script\u003e\n      \n  \n    "},{"id":"10027_100001","type":"chapter","name":"引擎编译缓存区管理策略","fullPath":"F:\\passerby\\web\\JavaScript引擎并行化研究与设计\\02引擎编译缓存区管理策略.md","url":"/chapter/10027_100001","content":"\n    \n    \n      \u003cdiv class=\"crossnote markdown-preview  \"\u003e\n      \n\u003ch1 id=\"javascript引擎编译缓存区管理策略\"\u003eJavaScript引擎编译缓存区管理策略 \u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在直接影响JavaScript引擎执行性能方面，即时编译执行和解释执行之间一个最重要的区别就是即时编译执行中JavaScript引擎设置了专门的编译缓存区来存储即时编译生成的对应平台的机器码，JavaScript引擎中的编译缓存区与电脑硬件上面的缓存不同，他是JavaScript引擎在内存中开辟的一块用于为即时编译服务的存储区域，当JavaScript引擎在执行过程总需要再次执行同一段JavaScript代码时，则直接从编译缓存区中查找，将响应的对应平台的机器码拷贝到执行缓冲池中进行执行，这样减少了JavaScript代码中的重新编译频率，提高了代码重用率，减少了编译开销。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"编译缓存区现有管理策略\"\u003e编译缓存区现有管理策略 \u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJavaScript引擎在对JavaScript代码进行即时编译时，主要工作包括了对JavaScript的编译和对生成的对应平台的机器码的链接，这些都是在编译缓存区中进行的，JavaScript引擎在即时编译时需要将编译生成的对应平台的机器码按照地址顺序连续的存储到编译缓存中，以确保生成的对应平台的机器码在执行时在物理地址上是连续的\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e由于JavaScript引擎对JavaScript代码即时编译生成的机器码无法事先预测大小，因此无法准确的确定编译缓存区的大小，如果编译缓存区的大小在初始化时设置的过大虽然会保证生成的机器码能够完全存入编译器缓存中，但是对于嵌入式设备有限的内存空间则会造成存储空间的资源紧张。而如果编译缓存区的大小设置的过小又会无法保证编译生成的机器码能够完整的存入缓存区中，因此JavaScript引擎现有的编译缓存区的管理策略是：首先，JavaScript引擎将编译缓存区的初始大小设置为一个M的阈值，随着JavaScript引擎对JavaScript代码即时编译生成的机器码存入编译缓存中，编译缓存区的空间减少，当机器码在存入编译缓存区之间空闲缓冲区的空间小于待存入的机器码的大小时，JavaScript引擎会重新开辟一个1.5倍大小与一个M的编译缓冲区，将新阈值设置为原先阈值的1.5倍。接着javas引擎会把原先编译缓存区中存储的机器码完整的拷贝到新开辟的编译缓存区中，同时释放原有的编译缓存区空间，随着即时编译过程的进行，如果新开辟的存储空间无法再次存入生成的机器码的时候，则需要再次使用该方式开辟新的编译缓存区空间，如下图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000142\" alt=\"现有编译缓存区管理策略\"\u003e\u003c/p\u003e\n\u003cp\u003e上述的管理策略虽然能够解决编译缓存区初始化设定大小和编译缓存区存储空间不够导致无法存入生成的机器码的问题，但是也存在一下问题：该管理策略中含有JavaScript引擎对新的存储空间的申请和开辟工作，大量机器码的拷贝工作以及原有存储空间的释放工作，这些执行操作会造成大量执行开销，导致嵌入式设备内存紧张，如果降低阈值的大小，开辟空间、拷贝数据和释放原空间的次数将会增加，浏览器在加载网页时的CPU占用率也将大大的增加，甚至出现“卡死”现象，编译缓存区是JavaScript引擎在即时编译模式下生成机器码和执行机器码的重要组成部分，该管理策略会严重降低JavaScript引擎在即时编译模式的执行效率，成为JavaScript引擎执行性能的瓶颈。因此需要对现有的JavaScript引擎的编译缓存器的管理策略进行改进，提高JavaScript引擎的执行效率\u003c/p\u003e\n\u003ch2 id=\"编译缓存区的管理策略改进和实现\"\u003e编译缓存区的管理策略改进和实现 \u003c/h2\u003e\n\u003cp\u003e为了解决上述问题，在改进的编译缓存区中，JavaScript引擎对编译缓存区空间离散的管理方式，将编译缓存区初始化大小设置为一个基本单元缓存块的大小，其管理模式为：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJavaScript引擎会在JavaScript引擎启动时预设编译缓存区的大小为一个固定值，而当JavaScript引擎将编译生成的某段机器码存入到编译缓存区时，JavaScript引擎仅仅只分配一块基本单元缓存块对机器码进行存储，并通过链表进行连接，如果存入空间不够JavaScript引擎再次分配一块基本单元缓存块用于存储某段机器码剩余的部分，这种存储空间分配方式即消除了嵌入式设备的内存空间的压力，也保证了存储空间的动态增长能够满足即时编译生成的机器码的存储，同时也提高了JavaScript引擎对编译编译缓冲区的管理效率\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"编译缓存区数据结构改进与设计\"\u003e编译缓存区数据结构改进与设计 \u003c/h2\u003e\n\u003ch3 id=\"编译缓存区数据结构分析\"\u003e编译缓存区数据结构分析 \u003c/h3\u003e\n\u003cp\u003eJavaScript引擎现有的编译缓存区的数据结构是数组结构，查找效率较低，机器码的存储开销也比较大，因此可以使用其他的数据结构来代替数组结构，也包括了哈希表。红黑树等，以减少JavaScript引擎即时编译生成的机器码存储开销，提高JavaScript引擎在执行时在编译缓存区中查找需要执行的机器码的效率\u003c/p\u003e\n\u003ch3 id=\"编译缓存区数据结构的改进与设计\"\u003e编译缓存区数据结构的改进与设计 \u003c/h3\u003e\n\u003cp\u003e由于编译缓存区只是JavaScript引擎生成的机器码的临时存放区域，JavaScript引擎在执行JavaScript代码是都会将相应的机器码从编译缓冲区拷贝到代码执行池中进行执行，因此只需要保证代码池中的机器码是连续的物理地址，就能使得JavaScript引擎在JavaScript代码时连续的，对于编译缓存区中机器码的存放则不需要保证在物理地址上的连续\u003c/p\u003e\n\u003cp\u003e因此对于编译缓存区的存储空间采用的是多个离散的基本单元缓存块的方式，可以采取哈希表的数据结构对不同的基本单元缓存块进行管理，而对于哈希表而言，哈希表在输入的数据集随机时容易出现大规模的冲突，虽然有很多有效的哈希函数，但是对于随机输入的数据集时，大规模的冲突还是不可避免的，出现最差的情况\u003c/p\u003e\n\u003cp\u003e在JavaScript引擎中，由于编译缓存区是一整块连续的物理地址空间，而基本单元缓存块的数量并不会是很多，因此基本单元缓存块的地址可以呈现均匀分布的状态，哈希表就不会出现大规模的冲突状况，而基本单元缓存块之间则用双链表进行链接，保证JavaScript引擎在执行JavaScript代码时能够寻找查找到对应的机器码\u003c/p\u003e\n\u003cp\u003e由于编译缓存区的基本单元 缓存块是链表结构，因此JavaScript引擎对需要执行的 JavaScript代码所对应的机器码的查找时间复杂度是O(n)。为了提高查找效率，因此可以通过哈希表对编译缓存区的基本单元缓存块进行管理。每次新分配的存入了机器码基本单元缓存块的地址都会更新到哈希表中，而清空一个或多个基本编译缓存块时则会从哈希表中移除。这样JavaScript引擎在查找需要执行的JavaScript代码所对应的机器码时直接通过哈希表进行查找，获取对应的机器码在编译缓存区中的位置，而查找的时间复杂度为O(1)大大降低了查找开销\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000143\" alt=\"基本单元缓存块的管理方式\"\u003e\u003c/p\u003e\n\u003cp\u003eCacheHandler结构作为这些独立的基本单元缓存块的管理者，是编译缓存区和的机器码执行的接口。CacheHandler结构使得编译缓存区的管理机制透明，同时与JavaScript引擎现有的编译缓存区的接口一致。JavaScript引擎通过CacheHandler结构提供的接口，就可以实现对即时编译生成的机器码的存储、链接以及将机器码拷贝代码执行池中\u003c/p\u003e\n\u003cpre data-role=\"codeBlock\" data-info=\"c++\" class=\"language-cpp c++\"\u003e\u003ccode\u003e\u003cspan class=\"token keyword keyword-class\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eCacheHandler\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword keyword-public\"\u003epublic\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-static\"\u003estatic\u003c/span\u003e CacheHandler\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token function\"\u003egetCacheHandler\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-bool\"\u003ebool\u003c/span\u003e \u003cspan class=\"token function\"\u003eregisternativeCode\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eNativeCode\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e nativeCode\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e size_t\u003cspan class=\"token operator\"\u003e\u0026amp;\u003c/span\u003e nativekey\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        NativeCode\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token function\"\u003egetNativeCode\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esize_t nativekey\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"token keyword keyword-private\"\u003eprivate\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"token function\"\u003eCacheHandler\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token operator\"\u003e~\u003c/span\u003e\u003cspan class=\"token function\"\u003eCacheHandler\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-static\"\u003estatic\u003c/span\u003e CacheHandler\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e m_cachehandler\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        size_t m_currentNativeCodeKey\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        Vector\u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003eNativeCode\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u0026gt;\u003c/span\u003e m_NativeCodePool\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"编译缓存区替换策略的设计\"\u003e编译缓存区替换策略的设计 \u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在JavaScript代码的执行过程中JavaScript引擎在执行过程中如果遇到已被编译过的JavaScript代码时，JavaScript引擎会从编译缓存区中查找相应的机器码，将相应的机器码拷贝到代码执行池中，而部分JavaScript代码需要频繁执行，而某些JavaScript代码则不会再次执行。因此可以将这一部分的机器码在编译缓存区中移除，而只需在编译缓存区中保留需要频繁执行的机器码，从而使得编译缓存区的大小固定在一定范围内，减少嵌入式设备的内存压力35。对此，本文根据上文所进行的编译缓存区的存储空间的管理方式和数据结构的改进设计两种编译缓存区的替换策略\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"基于计数器思想的替换策略\"\u003e基于计数器思想的替换策略 \u003c/h3\u003e\n\u003cp\u003e每个基本单元缓存块1到缓存块n中每个都有一个计数器，当某段机器码需要被再次执行时，存储改机器码的一个或者多个基本单元缓存块的计数都加1，如果有即时编译生成的机器码存入编译缓存区时编译缓存区的大小等于JavaScript引擎在启动时所设的固定值时，则需要根据计算器的大小，在将待存入的机器码直接存入到计算取最小的一个或者多个基本单元缓存块中，同时将该基本单元缓存块的计数器置为零\u003c/p\u003e\n\u003ch3 id=\"基于lru算法的替换策略\"\u003e基于LRU算法的替换策略 \u003c/h3\u003e\n\u003cp\u003e由于JavaScript引擎将编译缓存区中的各个基本编译缓存块通过链表进行连接，因此可以将各个基本编译缓存块通过双向链表连接起来，当待存入的机器码需要新分配基本编译缓存块存储时，则将新分配的基本编译缓存块置于链表的尾部，当JavaScript引擎需要再次执行某段JavaScript代码时，JavaScript引擎会在查找到所对应的机器吗后将其拷贝到代码池中执行，同时将对应的机器码所在的一个或者多个基本编译缓存块整体迁移到链表的尾部，这样JavaScript代码在经过多次执行后，最近被频繁执行的JavaScript代码对对应的机器码所在的基本编译块向链表表尾移动，执行次数很少或者没有被执行的JavaScript代码所对应的机器码所在的基本编译缓冲块则会向表头移动，当编译缓存区空间等于JavaScript引擎在启动时设定的阈值时，JavaScript引擎则可以将待存入的机器码直接存入到表头中，\u003c/p\u003e\n\n      \u003c/div\u003e\n      \u003cdiv class=\"md-sidebar-toc\"\u003e\n\u003cdiv class=\"md-toc\"\u003e\n\u003cdetails style=\"padding:0;;padding-left:0px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#javascript引擎编译缓存区管理策略\" class=\"md-toc-link\"\u003e\u003cp\u003eJavaScript引擎编译缓存区管理策略\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#编译缓存区现有管理策略\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e编译缓存区现有管理策略\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#编译缓存区的管理策略改进和实现\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e编译缓存区的管理策略改进和实现\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdetails style=\"padding:0;;padding-left:24px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#编译缓存区数据结构改进与设计\" class=\"md-toc-link\"\u003e\u003cp\u003e编译缓存区数据结构改进与设计\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#编译缓存区数据结构分析\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e编译缓存区数据结构分析\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#编译缓存区数据结构的改进与设计\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e编译缓存区数据结构的改进与设计\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/details\u003e\n    \u003cdetails style=\"padding:0;;padding-left:24px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#编译缓存区替换策略的设计\" class=\"md-toc-link\"\u003e\u003cp\u003e编译缓存区替换策略的设计\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#基于计数器思想的替换策略\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e基于计数器思想的替换策略\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#基于lru算法的替换策略\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e基于LRU算法的替换策略\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/details\u003e\n    \n        \u003c/div\u003e\n      \u003c/details\u003e\n    \n\u003c/div\u003e\n\u003c/div\u003e\n      \u003ca id=\"sidebar-toc-btn\"\u003e≡\u003c/a\u003e\n    \n    \n    \n    \n    \n    \n\u003cscript\u003e\n\nvar sidebarTOCBtn = document.getElementById('sidebar-toc-btn')\nsidebarTOCBtn.addEventListener('click', function(event) {\n  event.stopPropagation()\n  if (document.body.hasAttribute('html-show-sidebar-toc')) {\n    document.body.removeAttribute('html-show-sidebar-toc')\n  } else {\n    document.body.setAttribute('html-show-sidebar-toc', true)\n  }\n})\n\u003c/script\u003e\n      \n  \n    "},{"id":"10027_100002","type":"chapter","name":"引擎并行处理架构的设计与实现","fullPath":"F:\\passerby\\web\\JavaScript引擎并行化研究与设计\\03引擎并行处理架构的设计与实现.md","url":"/chapter/10027_100002","content":"\n    \n    \n      \u003cdiv class=\"crossnote markdown-preview  \"\u003e\n      \n\u003ch1 id=\"javascript引擎并行处理架构的设计与实现\"\u003eJavaScript引擎并行处理架构的设计与实现 \u003c/h1\u003e\n\u003cp\u003e尽管动态编译方式和缓存区优化模式能够有效的降低JavaScript引擎的内存开销和网页的加载时间，但是对于一些输入输出密集型的运算它的效率并不高。此外由于目前的JavaScript引擎都是单线程方式进行执行，对热点代码的探测、即时编译和即时编译模式与解释模式的切换都是线性的进行执行，无法充分的利用当前流行的多处理器底层平台的运行资源，时间开销较大。而且被即时编译之后的代码需要迅速被执行，也无法做到代码优化。\u003c/p\u003e\n\u003cp\u003e针对以上提出的优化技术的缺点，从当前的多线程技术的优化技术的角度出发，对热点代码的探测和对热点代码的即时编译的过程与对热点代码的执行过程进行分离进行并行即时编译与执行 。\u003c/p\u003e\n\u003ch2 id=\"并行处理架构研究\"\u003e并行处理架构研究 \u003c/h2\u003e\n\u003cp\u003e在JavaScript引擎的动态编译方式中当一个函数块被探测为热点区域后该函数块需要被进行即时编译，生成相应平台的机器码在该函数块被再次调用的时候JavaScript引擎则直接调用对应的机器码进行执行。\u003c/p\u003e\n\u003cp\u003e在动态编译方式中，即时编译模块与解释执行模块之间耦合度较低，只存在线性的数据交换与上下文切换。即时编译模块将即时编译生成的相应平台的机器码存入到编译缓存区中，而当解释执行模块在遇到上下文切换标记时则从相应代码编译缓存区中将需要执行的相应平台的机器码取出后进行执行。在动态编译执行流程中，其中只有在对于同一块代码缓存区进行存入和取出时存在读写冲突。\u003c/p\u003e\n\u003cp\u003e因此本文根据多线程的优化技术，采用了在多核处理器平台下的多线程的控制模式，将对热点区域代码的探测和对热点区域代码的即时编译过程都分别由一个独立于解释执行方式的线程来控制减少了在即时编译模式下由于代码过大即时编译时间过长所造成的等待时间过长的情况造成的JavaScript引擎执行时间增加导致网页加载时间过长，最终导致用户体验较差的问题。因此本文使用多线程在后台对JavaScript代码进行即时编译可以使得即时编译模块能够生成代码质量更好的相应平台的机器码\u003c/p\u003e\n\u003cp\u003e主要设计目的是利用目前的多线程优化技术和多核处理器平台环境来减少JavaScript代码在JavaScript引擎的执行过程中的各种开销；包括\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用多线程优化技术，使得即时编译和执行并行执行，减少了执行的等待开销\u003c/li\u003e\n\u003cli\u003e使用多线程优化技术，使得对JavaScript代码热点区域的探测和即时编译并行执行，减少了即时编译的等待开销\u003c/li\u003e\n\u003cli\u003e使用多线程优化技术，使得解释执行和对JavaScript代码热点区域的探测并行执行，减少了解释执行与即时编译执行的切换时间\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"多线程应用程序设计\"\u003e多线程应用程序设计 \u003c/h3\u003e\n\u003cp\u003e需要将应用程序划分为多个相独立的任务，这样的划分模式称为分解。目前常见的分解模式有三种：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e任务分解：类似的应用程序往往包括了几个功能相对独立的模块。各个线程通过系统的分配调度分区去完成这些独立的功能模块\u003c/li\u003e\n\u003cli\u003e数据分解：应用程序的各个线程对依赖性相对降低的各个数据对象进行同样的操作执行；\u003c/li\u003e\n\u003cli\u003e数据流分解：应用程序中的数据在各个任务 之间进行通信，通过对各个人物之间的进行通信的数据流进行分析，从而对应用程序程序进行相应的人物分解\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"引擎多线程划分\"\u003e引擎多线程划分 \u003c/h3\u003e\n\u003cp\u003e在JavaScript 引擎的执行过程中JavaScript代码被翻译为字节码后JavaScript引擎需要对字节码进行热点区域探测，当热点区域被探测之后需要进行即时编译，将热点区域的字节码即时编译为相应平台的机器码存入到编译缓存区中，并相应的字节码热点区域添加跳转标记。JavaScript引擎开始执行JavaScript代码时，如果在字节码中遇到跳转标记，则根据跳转标记执行跳转地址内的对于平台的机器码。如果在字节码中没有跳转标记，则按照解释执行的方式执行字节码。\u003c/p\u003e\n\u003cp\u003e在这其中，对字节码的热点区域探测过程和对字节码的即时编译过程之间存在着的是线性单向的数据之间的通信因为在对字节码的探测过程中，只是对字节码中的热点区域进行探测标记，而在对字节码中的热点区域进行即时编译的过程中，只需要对探测标记的字节码热点区域进行即时编译即可。因此，可将对字节码的热点区域探测过程与对字节码的热点区域的即时编译过程分解由两个线程来进行，前者被命名为探测线程””，后者被命名为即时编译线程。探测线程在启动之后会持续对字节码进行热点区域的探测并将探测出来的热点区域进行标记而即时编译线程则会通过对字节码进行扫描，当即时编译线程找到标记后，则对相应的字节码中的热点区域进行即时编译，对字节码中热点区域的即时编译过程与对已即时编译完成了的字节码中热点区域的所生成的对应平台的机器码的编译执行过程之间也只存在着线性单向的数据之间的通信，因为在对字节码中热点区域的即时编译过程中，只需要将即时编译所生成的对应平台的机器码存入到编译缓存区后即可，而编译执行过程则是将所需要执行的对应平台的机器码拷贝到执行缓冲池中进行编译执行。两者之间由编译缓存区为媒介，构成了典型的生产者消费者关系。因此，可将对字节码中热点区域的即时编译过程与对已即时编译完成了的字节码中热点区域的所生成的对应平台的机器码的编译执行过程分解由两个线程来运行上文中已将前者命名为即时编译线程而后者将被命名为编译执行线程。即时编译线程在对字节码中的热点区域进行即时编译之后，只是将生成的对应平台的机器码存入到编译缓存区中，而编译执行线程则只是在编译缓存区中进行查找，将需要进行编译执行的机器码拷贝到执行缓冲池中进行执行。此外，由于在JavaScript引擎中，对字节码的解释执行和对字节码的编译执行的切换行为的主要根据的是字节码上的跳转标记，但是可能出现由于所需要编译的字节码中的热点区域过大，即时编译时间较长，因此可能会造成JavaScript引擎出现等待即时编译的情况，增加编译时间开销。而JavaScript引擎的字节码的解释执行过程与编译过程的功能都是独立的模块，因此可以将这两个过程分解为两个线程来运行。前者将被命名为主线程而后者则包括了上文中所命名的探测线程、即时编译线程和编译执行线程\u003c/p\u003e\n\u003ch3 id=\"线程间依赖性分析\"\u003e线程间依赖性分析 \u003c/h3\u003e\n\u003cp\u003e探测线程与即时编译线程之间虽然只是存在简单的线程单向的数据间的通信，但是两者间还是有一定的依赖性关系。探测线程在探测到字节码中热点区域时，需要将所需即时编译的热点区域的地址发送给即时编译线程，即时编译线程只有获取了需要即时编译的热点区域的地址后才能进行即时编译。如果即时编译线程没有获取到需要即时编译的字节码的热点区域的地址，即时编译线程将进行等待，直到探测线程将所需要进行即时编译的字节码的热点区域的地址发送给即时编译线程。这种情况所造成的影响是，如果即时编译线程无法在需要即时编译之前获得需要即时编译的字节码中的热点区域的地址，那么即时编译线程就无法和探测线程并行的执行，从而导致JavaScript引擎对字节码中的热点区域的编译执行方式退化为和之前的JavaScript引擎一样的线性执行模式，从而降低了JavaScript引擎的并行系统的性能优势。\u003c/p\u003e\n\u003cp\u003e同时由于编译执行线程在编译执行需要执行的对应平台的机器码时，需要在编译缓存区中进行寻找，如果在寻找的过程中即时编译线程并没有将所需执行的机器码所对应得字节码进行编译，则编译线程则需要进行等待，增加了JavaScript引擎的执行时间。此外，主线程如果在解释执行的过程中在字节码中遇到了跳转标记，则需要调用编译执行线程对跳转标记中所对应的热点区域的机器码进行编译执行，如果即时编译线程并没有将所需执行的机器码所对应得字节码进行编译，则编译线程则需要进行等待，而主线程也将等待使得JavaScript引擎的等待开销大量增加，降低了用户体验性能。\u003c/p\u003e\n\u003ch2 id=\"并行系统架构设计\"\u003e并行系统架构设计 \u003c/h2\u003e\n\u003cp\u003eJavaScript引擎的并行处理架构是基于WebKit小组开发的SquirrelFishExtremeJavaScript引擎是将JavaScript引擎的各个功能模块进多线程任务的划分和并行化设计后所形成的多线程系统。它使用了一系列的优化方案，目的在于能够利用当前的多核处理器平台，实现对于热点区域代码块的即时编译与优化缓存区。使得JavaScript引擎能够减少内存消耗和网页的加载时间\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000144\" alt=\"并行模型\"\u003e\u003c/p\u003e\n\u003ch3 id=\"模块分析\"\u003e模块分析 \u003c/h3\u003e\n\u003cp\u003e架构上看，JavaScript引擎并行系统分为个功能模块，分别为：初始化模块、解释执行模块、热点区域探测模块、即时编译模块、缓存区管理模块、编译执行模块。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e代码加载模块：JavaScript引擎启动后，JavaScript代码将被翻译成为抽象语法生成树。\u003cbr\u003e\n字节码翻译模块：将语法生成树翻译为对应的字节码。\u003c/li\u003e\n\u003cli\u003e热点区域探测模块：根据上文所述算法对JavaScript代码所生产的字节码进行热点区域探测，标记热点区域。\u003c/li\u003e\n\u003cli\u003e即时编译模块：对被探测为热点区域的JavaScript代码进行即时编译。并将即时编译后生成的对应平台的机器码存入缓存区中，同时在对应的字节码处添加跳转标记。\u003c/li\u003e\n\u003cli\u003e编译缓存区管理模块：对即时编译后生成的对应平台的机器码进行管理。\u003c/li\u003e\n\u003cli\u003e解释执行模块：在解释模式下对JavaScript代码进行执行。\u003c/li\u003e\n\u003cli\u003e编译执行模块：在即时编译模式下对JavaScript代码进行执行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"工作流程\"\u003e工作流程 \u003c/h3\u003e\n\u003cp\u003eJavaScript 引擎并行系统的执行分为主线程、探测线程、即时编译线程和编译执行线程四个线程\u003c/p\u003e\n\u003cp\u003e主线程在JavaScript 引擎开始执行时便已存在，经过初始化模块和翻译模块后主线程便启动探测线程，经过热点区域探测模块后主线程便启动即时编译线程\u003c/p\u003e\n\u003cp\u003e主线程主要负责初始化模块、翻译模块和解释执行模块。探测线程主要负责热点区域探测模块，而即时编译线程主要负责即时编译模块和缓存区管理模块\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000145\" alt=\"主线程工作流程\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000146\" alt=\"探测线程工作流程\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000147\" alt=\"即时编译线程\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000148\" alt=\"编译执行工作流程\"\u003e\u003c/p\u003e\n\u003ch2 id=\"线程的实现\"\u003e线程的实现 \u003c/h2\u003e\n\u003cpre data-role=\"codeBlock\" data-info=\"c++\" class=\"language-cpp c++\"\u003e\u003ccode\u003e\u003cspan class=\"token keyword keyword-class\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eJSThread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword keyword-public\"\u003epublic\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"token function\"\u003eJSThread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"token operator\"\u003e~\u003c/span\u003e\u003cspan class=\"token function\"\u003eJSThread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n        \u003cspan class=\"token keyword keyword-int\"\u003eint\u003c/span\u003e \u003cspan class=\"token function\"\u003estart\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-int\"\u003eint\u003c/span\u003e \u003cspan class=\"token function\"\u003ewait\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-void\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003eterminate\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-void\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003esetStopFlag\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-bool\"\u003ebool\u003c/span\u003e \u003cspan class=\"token function\"\u003egetStopFlag\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-unsigned\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"token keyword keyword-int\"\u003eint\u003c/span\u003e \u003cspan class=\"token function\"\u003egetTID\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-void\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003esetThreadArg\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eJSThreadArg \u003cspan class=\"token operator\"\u003e*\u003c/span\u003epThrArg \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e null\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-virtual\"\u003evirtual\u003c/span\u003e \u003cspan class=\"token keyword keyword-void\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003erun\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\n    \u003cspan class=\"token keyword keyword-private\"\u003eprivate\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-struct\"\u003estruct\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eJSThreadArg\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n            JSThread\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e m_pThread\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n            \u003cspan class=\"token keyword keyword-void\"\u003evoid\u003c/span\u003e\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e m_pArg\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n        JSThreadArg\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e m_pThrArg\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        pthread_attr_t m_attr\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        pthread_t m_dwThreadId\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-bool\"\u003ebool\u003c/span\u003e m_bStopFlag\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-bool\"\u003ebool\u003c/span\u003e m_bStarted\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-static\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword keyword-void\"\u003evoid\u003c/span\u003e\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token function\"\u003eroutine\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword keyword-void\"\u003evoid\u003c/span\u003e\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e arg\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"/assets/100000149\" alt=\"线程运行流程\"\u003e\u003c/p\u003e\n\u003ch2 id=\"线程资源锁的设计与实现\"\u003e线程资源锁的设计与实现 \u003c/h2\u003e\n\u003cp\u003e当即时编译线程在字节码中添加跳转标记时如果主线程正在对字节码进行解释执行，则即时编译线程必须等待主线程将该段字节码解释执行完成之后才进行修改。因此即时编译线程会与解释执行线程出现互斥现象，需要加锁机制来解决\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000150\" alt=\"主线程与即时编译线程互斥流程\"\u003e\u003c/p\u003e\n\u003ch2 id=\"消息通信的设计\"\u003e消息通信的设计 \u003c/h2\u003e\n\u003cp\u003e消息通信实现了线程间的信息交流。在JavaScript引擎的并行系统中，线程间的消息交换需要递交给主线程的消息交换模块，由消息交换模块根据各个线程的优先等级和递交先后进行处\u003c/p\u003e\n\u003cp\u003e消息交换模块 中含有根据各个线程的优先等级将线程传递的消息进行排序的队列。当某个线程发送消息到消息交换模块后，消息交换模块根据各个线程的有\u003cbr\u003e\n限等级将将消息按照等级顺序插入到消息队列中。如果优先等级一样，则按照到达时间的先后进行排序。消息交换模块对消息的传递从队首到队尾的顺序进行按照消息中含有的需要传递的目标线程将消息发送到相应的线程中去\u003c/p\u003e\n\u003cp\u003e在JavaScript引擎中，主线程发送的消息和主要是关于解释执行与编译执行之间的切换信息。由于解释执行与编译执行的切换是否及时影响到了JavaScript引擎能否及时执行JavaScript代码因此主线程发送的消息的优先级为最高。对于编译执行线程而言，当其对热点区域的机器码编译执行完毕后，需要通知主线程编译执行完毕，需要切换到解释执行状态，这也影响到JavaScript引擎的执行效率因此编译执行线程的优先等级也和主线程一样，属于最高优先级。而即时编译线程由于只是对探测线程所判定的JavaScript代码中的热点区域的字节码进行即时编译，因此其等级属于最低优先等级。探测线程的主要目的是实现对于JavaScript代码热点区域的探测，提高JavaScript引擎的编译效率，节约编译开销但是由于其并不影响JavaScript引擎对JavaScript代码的执行，因此其优先等级在主线程、编译执行线程和即时编译线程之间。\u003c/p\u003e\n\u003cp\u003e在消息交换模块中，线程的优先等级采用一个Priori结构来存储，包含在线程所发送的消息中。所示，优先等级中第一位为最高优先级最后一位为最低优先级。当某个位置被设为1时，则表示该线程的优先等级是相应的优先级。消息交换模块通过某个线程发送的消息中的Priori结构读出该线程的优先级，继而将消息按照相应的顺序在队列中进行排序如下表\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:center\"\u003e主线程\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e编译执行线程\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e探测线程\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e即时编译线程\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e第1等级\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e第1等级\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e第2等级\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e第3等级\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n      \u003c/div\u003e\n      \u003cdiv class=\"md-sidebar-toc\"\u003e\n\u003cdiv class=\"md-toc\"\u003e\n\u003cdetails style=\"padding:0;;padding-left:0px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#javascript引擎并行处理架构的设计与实现\" class=\"md-toc-link\"\u003e\u003cp\u003eJavaScript引擎并行处理架构的设计与实现\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdetails style=\"padding:0;;padding-left:24px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#并行处理架构研究\" class=\"md-toc-link\"\u003e\u003cp\u003e并行处理架构研究\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#多线程应用程序设计\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e多线程应用程序设计\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#引擎多线程划分\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e引擎多线程划分\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#线程间依赖性分析\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e线程间依赖性分析\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/details\u003e\n    \u003cdetails style=\"padding:0;;padding-left:24px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#并行系统架构设计\" class=\"md-toc-link\"\u003e\u003cp\u003e并行系统架构设计\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#模块分析\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e模块分析\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#工作流程\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e工作流程\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/details\u003e\n    \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#线程的实现\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e线程的实现\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#线程资源锁的设计与实现\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e线程资源锁的设计与实现\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#消息通信的设计\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e消息通信的设计\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/details\u003e\n    \n\u003c/div\u003e\n\u003c/div\u003e\n      \u003ca id=\"sidebar-toc-btn\"\u003e≡\u003c/a\u003e\n    \n    \n    \n    \n    \n    \n\u003cscript\u003e\n\nvar sidebarTOCBtn = document.getElementById('sidebar-toc-btn')\nsidebarTOCBtn.addEventListener('click', function(event) {\n  event.stopPropagation()\n  if (document.body.hasAttribute('html-show-sidebar-toc')) {\n    document.body.removeAttribute('html-show-sidebar-toc')\n  } else {\n    document.body.setAttribute('html-show-sidebar-toc', true)\n  }\n})\n\u003c/script\u003e\n      \n  \n    "}],"type":"book","url":"/book/10027"},"chapterInfo":{"id":"10027_100001","type":"chapter","name":"引擎编译缓存区管理策略","fullPath":"F:\\passerby\\web\\JavaScript引擎并行化研究与设计\\02引擎编译缓存区管理策略.md","url":"/chapter/10027_100001","content":"\n    \n    \n      \u003cdiv class=\"crossnote markdown-preview  \"\u003e\n      \n\u003ch1 id=\"javascript引擎编译缓存区管理策略\"\u003eJavaScript引擎编译缓存区管理策略 \u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在直接影响JavaScript引擎执行性能方面，即时编译执行和解释执行之间一个最重要的区别就是即时编译执行中JavaScript引擎设置了专门的编译缓存区来存储即时编译生成的对应平台的机器码，JavaScript引擎中的编译缓存区与电脑硬件上面的缓存不同，他是JavaScript引擎在内存中开辟的一块用于为即时编译服务的存储区域，当JavaScript引擎在执行过程总需要再次执行同一段JavaScript代码时，则直接从编译缓存区中查找，将响应的对应平台的机器码拷贝到执行缓冲池中进行执行，这样减少了JavaScript代码中的重新编译频率，提高了代码重用率，减少了编译开销。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"编译缓存区现有管理策略\"\u003e编译缓存区现有管理策略 \u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJavaScript引擎在对JavaScript代码进行即时编译时，主要工作包括了对JavaScript的编译和对生成的对应平台的机器码的链接，这些都是在编译缓存区中进行的，JavaScript引擎在即时编译时需要将编译生成的对应平台的机器码按照地址顺序连续的存储到编译缓存中，以确保生成的对应平台的机器码在执行时在物理地址上是连续的\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e由于JavaScript引擎对JavaScript代码即时编译生成的机器码无法事先预测大小，因此无法准确的确定编译缓存区的大小，如果编译缓存区的大小在初始化时设置的过大虽然会保证生成的机器码能够完全存入编译器缓存中，但是对于嵌入式设备有限的内存空间则会造成存储空间的资源紧张。而如果编译缓存区的大小设置的过小又会无法保证编译生成的机器码能够完整的存入缓存区中，因此JavaScript引擎现有的编译缓存区的管理策略是：首先，JavaScript引擎将编译缓存区的初始大小设置为一个M的阈值，随着JavaScript引擎对JavaScript代码即时编译生成的机器码存入编译缓存中，编译缓存区的空间减少，当机器码在存入编译缓存区之间空闲缓冲区的空间小于待存入的机器码的大小时，JavaScript引擎会重新开辟一个1.5倍大小与一个M的编译缓冲区，将新阈值设置为原先阈值的1.5倍。接着javas引擎会把原先编译缓存区中存储的机器码完整的拷贝到新开辟的编译缓存区中，同时释放原有的编译缓存区空间，随着即时编译过程的进行，如果新开辟的存储空间无法再次存入生成的机器码的时候，则需要再次使用该方式开辟新的编译缓存区空间，如下图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000142\" alt=\"现有编译缓存区管理策略\"\u003e\u003c/p\u003e\n\u003cp\u003e上述的管理策略虽然能够解决编译缓存区初始化设定大小和编译缓存区存储空间不够导致无法存入生成的机器码的问题，但是也存在一下问题：该管理策略中含有JavaScript引擎对新的存储空间的申请和开辟工作，大量机器码的拷贝工作以及原有存储空间的释放工作，这些执行操作会造成大量执行开销，导致嵌入式设备内存紧张，如果降低阈值的大小，开辟空间、拷贝数据和释放原空间的次数将会增加，浏览器在加载网页时的CPU占用率也将大大的增加，甚至出现“卡死”现象，编译缓存区是JavaScript引擎在即时编译模式下生成机器码和执行机器码的重要组成部分，该管理策略会严重降低JavaScript引擎在即时编译模式的执行效率，成为JavaScript引擎执行性能的瓶颈。因此需要对现有的JavaScript引擎的编译缓存器的管理策略进行改进，提高JavaScript引擎的执行效率\u003c/p\u003e\n\u003ch2 id=\"编译缓存区的管理策略改进和实现\"\u003e编译缓存区的管理策略改进和实现 \u003c/h2\u003e\n\u003cp\u003e为了解决上述问题，在改进的编译缓存区中，JavaScript引擎对编译缓存区空间离散的管理方式，将编译缓存区初始化大小设置为一个基本单元缓存块的大小，其管理模式为：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJavaScript引擎会在JavaScript引擎启动时预设编译缓存区的大小为一个固定值，而当JavaScript引擎将编译生成的某段机器码存入到编译缓存区时，JavaScript引擎仅仅只分配一块基本单元缓存块对机器码进行存储，并通过链表进行连接，如果存入空间不够JavaScript引擎再次分配一块基本单元缓存块用于存储某段机器码剩余的部分，这种存储空间分配方式即消除了嵌入式设备的内存空间的压力，也保证了存储空间的动态增长能够满足即时编译生成的机器码的存储，同时也提高了JavaScript引擎对编译编译缓冲区的管理效率\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"编译缓存区数据结构改进与设计\"\u003e编译缓存区数据结构改进与设计 \u003c/h2\u003e\n\u003ch3 id=\"编译缓存区数据结构分析\"\u003e编译缓存区数据结构分析 \u003c/h3\u003e\n\u003cp\u003eJavaScript引擎现有的编译缓存区的数据结构是数组结构，查找效率较低，机器码的存储开销也比较大，因此可以使用其他的数据结构来代替数组结构，也包括了哈希表。红黑树等，以减少JavaScript引擎即时编译生成的机器码存储开销，提高JavaScript引擎在执行时在编译缓存区中查找需要执行的机器码的效率\u003c/p\u003e\n\u003ch3 id=\"编译缓存区数据结构的改进与设计\"\u003e编译缓存区数据结构的改进与设计 \u003c/h3\u003e\n\u003cp\u003e由于编译缓存区只是JavaScript引擎生成的机器码的临时存放区域，JavaScript引擎在执行JavaScript代码是都会将相应的机器码从编译缓冲区拷贝到代码执行池中进行执行，因此只需要保证代码池中的机器码是连续的物理地址，就能使得JavaScript引擎在JavaScript代码时连续的，对于编译缓存区中机器码的存放则不需要保证在物理地址上的连续\u003c/p\u003e\n\u003cp\u003e因此对于编译缓存区的存储空间采用的是多个离散的基本单元缓存块的方式，可以采取哈希表的数据结构对不同的基本单元缓存块进行管理，而对于哈希表而言，哈希表在输入的数据集随机时容易出现大规模的冲突，虽然有很多有效的哈希函数，但是对于随机输入的数据集时，大规模的冲突还是不可避免的，出现最差的情况\u003c/p\u003e\n\u003cp\u003e在JavaScript引擎中，由于编译缓存区是一整块连续的物理地址空间，而基本单元缓存块的数量并不会是很多，因此基本单元缓存块的地址可以呈现均匀分布的状态，哈希表就不会出现大规模的冲突状况，而基本单元缓存块之间则用双链表进行链接，保证JavaScript引擎在执行JavaScript代码时能够寻找查找到对应的机器码\u003c/p\u003e\n\u003cp\u003e由于编译缓存区的基本单元 缓存块是链表结构，因此JavaScript引擎对需要执行的 JavaScript代码所对应的机器码的查找时间复杂度是O(n)。为了提高查找效率，因此可以通过哈希表对编译缓存区的基本单元缓存块进行管理。每次新分配的存入了机器码基本单元缓存块的地址都会更新到哈希表中，而清空一个或多个基本编译缓存块时则会从哈希表中移除。这样JavaScript引擎在查找需要执行的JavaScript代码所对应的机器码时直接通过哈希表进行查找，获取对应的机器码在编译缓存区中的位置，而查找的时间复杂度为O(1)大大降低了查找开销\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/100000143\" alt=\"基本单元缓存块的管理方式\"\u003e\u003c/p\u003e\n\u003cp\u003eCacheHandler结构作为这些独立的基本单元缓存块的管理者，是编译缓存区和的机器码执行的接口。CacheHandler结构使得编译缓存区的管理机制透明，同时与JavaScript引擎现有的编译缓存区的接口一致。JavaScript引擎通过CacheHandler结构提供的接口，就可以实现对即时编译生成的机器码的存储、链接以及将机器码拷贝代码执行池中\u003c/p\u003e\n\u003cpre data-role=\"codeBlock\" data-info=\"c++\" class=\"language-cpp c++\"\u003e\u003ccode\u003e\u003cspan class=\"token keyword keyword-class\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eCacheHandler\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword keyword-public\"\u003epublic\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-static\"\u003estatic\u003c/span\u003e CacheHandler\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token function\"\u003egetCacheHandler\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-bool\"\u003ebool\u003c/span\u003e \u003cspan class=\"token function\"\u003eregisternativeCode\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eNativeCode\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e nativeCode\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e size_t\u003cspan class=\"token operator\"\u003e\u0026amp;\u003c/span\u003e nativekey\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        NativeCode\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token function\"\u003egetNativeCode\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esize_t nativekey\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"token keyword keyword-private\"\u003eprivate\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"token function\"\u003eCacheHandler\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token operator\"\u003e~\u003c/span\u003e\u003cspan class=\"token function\"\u003eCacheHandler\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token keyword keyword-static\"\u003estatic\u003c/span\u003e CacheHandler\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e m_cachehandler\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        size_t m_currentNativeCodeKey\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        Vector\u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003eNativeCode\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u0026gt;\u003c/span\u003e m_NativeCodePool\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"编译缓存区替换策略的设计\"\u003e编译缓存区替换策略的设计 \u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在JavaScript代码的执行过程中JavaScript引擎在执行过程中如果遇到已被编译过的JavaScript代码时，JavaScript引擎会从编译缓存区中查找相应的机器码，将相应的机器码拷贝到代码执行池中，而部分JavaScript代码需要频繁执行，而某些JavaScript代码则不会再次执行。因此可以将这一部分的机器码在编译缓存区中移除，而只需在编译缓存区中保留需要频繁执行的机器码，从而使得编译缓存区的大小固定在一定范围内，减少嵌入式设备的内存压力35。对此，本文根据上文所进行的编译缓存区的存储空间的管理方式和数据结构的改进设计两种编译缓存区的替换策略\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"基于计数器思想的替换策略\"\u003e基于计数器思想的替换策略 \u003c/h3\u003e\n\u003cp\u003e每个基本单元缓存块1到缓存块n中每个都有一个计数器，当某段机器码需要被再次执行时，存储改机器码的一个或者多个基本单元缓存块的计数都加1，如果有即时编译生成的机器码存入编译缓存区时编译缓存区的大小等于JavaScript引擎在启动时所设的固定值时，则需要根据计算器的大小，在将待存入的机器码直接存入到计算取最小的一个或者多个基本单元缓存块中，同时将该基本单元缓存块的计数器置为零\u003c/p\u003e\n\u003ch3 id=\"基于lru算法的替换策略\"\u003e基于LRU算法的替换策略 \u003c/h3\u003e\n\u003cp\u003e由于JavaScript引擎将编译缓存区中的各个基本编译缓存块通过链表进行连接，因此可以将各个基本编译缓存块通过双向链表连接起来，当待存入的机器码需要新分配基本编译缓存块存储时，则将新分配的基本编译缓存块置于链表的尾部，当JavaScript引擎需要再次执行某段JavaScript代码时，JavaScript引擎会在查找到所对应的机器吗后将其拷贝到代码池中执行，同时将对应的机器码所在的一个或者多个基本编译缓存块整体迁移到链表的尾部，这样JavaScript代码在经过多次执行后，最近被频繁执行的JavaScript代码对对应的机器码所在的基本编译块向链表表尾移动，执行次数很少或者没有被执行的JavaScript代码所对应的机器码所在的基本编译缓冲块则会向表头移动，当编译缓存区空间等于JavaScript引擎在启动时设定的阈值时，JavaScript引擎则可以将待存入的机器码直接存入到表头中，\u003c/p\u003e\n\n      \u003c/div\u003e\n      \u003cdiv class=\"md-sidebar-toc\"\u003e\n\u003cdiv class=\"md-toc\"\u003e\n\u003cdetails style=\"padding:0;;padding-left:0px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#javascript引擎编译缓存区管理策略\" class=\"md-toc-link\"\u003e\u003cp\u003eJavaScript引擎编译缓存区管理策略\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#编译缓存区现有管理策略\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e编译缓存区现有管理策略\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#编译缓存区的管理策略改进和实现\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e编译缓存区的管理策略改进和实现\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdetails style=\"padding:0;;padding-left:24px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#编译缓存区数据结构改进与设计\" class=\"md-toc-link\"\u003e\u003cp\u003e编译缓存区数据结构改进与设计\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#编译缓存区数据结构分析\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e编译缓存区数据结构分析\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#编译缓存区数据结构的改进与设计\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e编译缓存区数据结构的改进与设计\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/details\u003e\n    \u003cdetails style=\"padding:0;;padding-left:24px;\" open=\"\"\u003e\n        \u003csummary class=\"md-toc-link-wrapper\"\u003e\n          \u003ca href=\"#编译缓存区替换策略的设计\" class=\"md-toc-link\"\u003e\u003cp\u003e编译缓存区替换策略的设计\u003c/p\u003e\n\u003c/a\u003e\n          \u003c/summary\u003e\n        \u003cdiv\u003e\n          \u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#基于计数器思想的替换策略\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e基于计数器思想的替换策略\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\u003cdiv class=\"md-toc-link-wrapper\" style=\"padding:0;;display:list-item;list-style:square;margin-left:42px\"\u003e\n          \u003ca href=\"#基于lru算法的替换策略\" class=\"md-toc-link\"\u003e\n            \u003cp\u003e基于LRU算法的替换策略\u003c/p\u003e\n\n          \u003c/a\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/details\u003e\n    \n        \u003c/div\u003e\n      \u003c/details\u003e\n    \n\u003c/div\u003e\n\u003c/div\u003e\n      \u003ca id=\"sidebar-toc-btn\"\u003e≡\u003c/a\u003e\n    \n    \n    \n    \n    \n    \n\u003cscript\u003e\n\nvar sidebarTOCBtn = document.getElementById('sidebar-toc-btn')\nsidebarTOCBtn.addEventListener('click', function(event) {\n  event.stopPropagation()\n  if (document.body.hasAttribute('html-show-sidebar-toc')) {\n    document.body.removeAttribute('html-show-sidebar-toc')\n  } else {\n    document.body.setAttribute('html-show-sidebar-toc', true)\n  }\n})\n\u003c/script\u003e\n      \n  \n    "}},"__N_SSG":true},"page":"/chapter/[chapterId]","query":{"chapterId":"10027_100001"},"buildId":"delumengma","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>