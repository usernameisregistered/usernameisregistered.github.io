<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>栈和队列-数据结构与算法-得鹿梦鱼</title>
  <link rel="shortcut icon" href="/assets/images/favicon.ico">
    <meta name="Author" content="liming_longxi@163.com">
    <meta name="Keywords" content="栈和队列"/>
  <link rel="stylesheet" href="/assets/styles/main.css" />
  <link rel="stylesheet" href="/assets/styles/katex/common.css" />
  <link rel="stylesheet" href="/assets/styles/katex/katex.min.css" />
  <script src="/assets/script/highlight.js"></script>
</head>

<body data-for="html-export">
  <div class="w-screen h-screen flex flex-col overflow-hidden">
    <header class="flex flex-grow-0 justify-between p-4 border-b border-neutral-200">
      <a href="/" class="flex items-center text-2xl text-neutral-700 cursor-pointer">
        <img src="/assets/images/logo.svg" class="w-[40px] h-[40px]" alt="得鹿梦鱼"></Image>
        <span class="text-4 ml-4">得鹿梦鱼</span>
      </a>
      <div class="right flex items-center cursor-pointer">
        <a href="/classify.html" class="mr-2 text-md hover:text-sky-500">知识库</a>
        <a href="/frontend.html" class="mr-2 text-md hover:text-sky-500">前端技能树</a>
        <a href="/question.html" class="mr-2 text-md hover:text-sky-500">面试题</a>
        <a href="/study.html" class="mr-2 text-md hover:text-sky-500">学习资料</a>
        <a href="/about.html" class="mr-2 text-md hover:text-sky-500">关于本人</a>
      </div>
    </header>
    <main class="flex-grow-1 overflow-hidden scrollHeight">
      <div class="w-screen flex flex-1">
        <aside class="basis-2/12 border-r border-gray-300 h-full overflow-hidden">
          <div class="text-md font-bold text-gray-700 m-4">数据结构与算法</div>
          <div class="overflow-x-hidden overflow-y-auto scrollChapterHeight scrollbar flex flex-col">
            <a class="text-md block mx-4 mb-2 cursor-pointer overflow-hidden text-ellipsis whitespace-nowrap hover:text-sky-300" href="/10021_100000.html" title="引言">引言
            </a>
            <a class="text-md block mx-4 mb-2 cursor-pointer overflow-hidden text-ellipsis whitespace-nowrap hover:text-sky-300" href="/10021_100001.html" title="线性表">线性表
            </a>
            <a class="text-md block mx-4 mb-2 cursor-pointer overflow-hidden text-ellipsis whitespace-nowrap hover:text-sky-300" href="/10021_100002.html" title="栈和队列">栈和队列
            </a>
            <a class="text-md block mx-4 mb-2 cursor-pointer overflow-hidden text-ellipsis whitespace-nowrap hover:text-sky-300" href="/10021_100003.html" title="串">串
            </a>
            <a class="text-md block mx-4 mb-2 cursor-pointer overflow-hidden text-ellipsis whitespace-nowrap hover:text-sky-300" href="/10021_100004.html" title="扩展">扩展
            </a>
          </div>
        </aside>
        <section class="basis-10/12 overflow-x-hidden overflow-y-auto scrollChapterHeight scrollbar">
          <div id="markdown-container" class="px-4 relative">
            
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="栈和队列">栈和队列 </h1>
<blockquote>
<p>栈只允许在表的一端进行插入或删除操作，而队列只允许在表的一端进行插入操作、在另一端进行删除操作。因而，栈和队列也可以被称为操作受限的线性表</p>
</blockquote>
<h2 id="栈">栈 </h2>
<p>栈(stack)是一种只允许在一端进行插入和删除操作的线性表，它是一种操作受限的线性表。在表中允许进行插入和删除的一端称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong>。栈的插入操作通常称为<strong>入栈</strong>或<strong>进栈</strong>而栈的删除操作则称为<strong>出栈</strong>或<strong>退栈</strong>当栈中无数据元素时，称为<strong>空栈</strong></p>
<p>根据栈的定义，每次进栈的元素都被放在原栈顶元素之上而成为新的栈顶，而每次出栈的总是当前栈中“最新”的元素，即最后进栈的元素;<strong>后进先出</strong></p>
<h3 id="多栈共享邻接空间">多栈共享邻接空间 </h3>
<p>G在计算机系统软件中，各种高级语言的编译系统都离不开栈的使用。常常一个程序中要用到多个栈，若采用顺序栈，会因为所需的栈空间大小难以准确估计，导致出现有的栈空间溢出、有的栈空间空闲的情况。为了不发生上溢错误，就必须给每个栈预先分配一个足够大的存储空间，但实际中很难准确地估计。另一方面，若每个栈都预分配过大的存储空间，势必会造成系统空间紧张。紧张。若让多个栈共用一个足够大的连续存储空间，则可利用栈的动态特性使其存储空间互补。这就是栈的共享邻接空间。</p>
<h2 id="应用">应用 </h2>
<ol>
<li>算术表达式求值</li>
</ol>
<p>计值的实现可以通过设置两个栈来完成。<br>
<strong>操作数栈(OPRD)</strong>: 用来存放处理表达是过程中的操作数<br>
<strong>运算符栈(OPTR)</strong>: 存放处理表达式过程中的运算符，开始时，先在运算符栈栈底压入一个表达式的结束符*#*<br>
计算机系统在处理表达式时，从左到右依次读出表达式中的各个符号（操作数或运算符），每读出一个符号后，根据运算规则做如下的处理。假如是操作数，则将其压入操作数栈，并依次读下一个符号。假如是运算符，则与运算符栈的栈顶运算符进行优先级比较，并做以以下处理</p>
<ul>
<li>假如读出的运算符的优先级高于运算符栈栈顶运算符的优先级，则将其压入运算符栈，并依次读下一个符号</li>
<li>假如读出的运算符的优先级等于运算符栈栈顶运算符的优先级，说明左右括号相遇，只需将栈顶运算符退栈即可</li>
<li>#假如读出的运算符的优先级低于运算符栈栈顶运算符的优先级，则从操作数栈连续退出两个操作数，从运算符栈中退出一个运算符，然后做相应的运算，并将运算结果压入操作数栈</li>
<li>假如读出的是表达式结束符*#<em>，且运算符栈栈顶的运算符也为</em>#*，则表达式处理结束，最后的表达式的计算结果在操作数栈的栈顶位置</li>
</ul>
<p>表1 表达式3+4*2计算过程栈区变化表</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>操作数栈</th>
<th>运算符栈</th>
<th>尚待读入的表达式</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td></td>
<td>#</td>
<td>3+4*2#</td>
<td>初始状态</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>#</td>
<td>+4*2#</td>
<td>读入3</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>#+</td>
<td>4*2#</td>
<td>读入+</td>
</tr>
<tr>
<td>4</td>
<td>3,4</td>
<td>#+</td>
<td>*2#</td>
<td>读入4</td>
</tr>
<tr>
<td>5</td>
<td>3,4</td>
<td>#+*</td>
<td>2#</td>
<td>读入2#</td>
</tr>
<tr>
<td>6</td>
<td>3,4，2</td>
<td>#+*</td>
<td>#</td>
<td>读入2</td>
</tr>
<tr>
<td>7</td>
<td>3， 8</td>
<td>#+</td>
<td>#</td>
<td>计算4*2</td>
</tr>
<tr>
<td>8</td>
<td>11</td>
<td>#</td>
<td>#</td>
<td>计算3+8</td>
</tr>
<tr>
<td>9</td>
<td></td>
<td></td>
<td></td>
<td>结束</td>
</tr>
</tbody>
</table>
<p><strong>栈与递归过程</strong></p>
<p>栈的一个重要应用是在程序设计语言中实现递归过程。递归即在定义自身的同时又出现了对自身的调用。如果一个函数在其定义体内直接调用自己，则称其为“直接递归函数”。如果一个函数经过一系列中间调用语句，通过其他函数间接调用自己，则称其为“间接递函数归”</p>
<p>有很多数学函数是递归定义的，如阶乘函数的定义<br>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mspace width="2em"></mspace><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mspace width="2em"></mspace><mi>n</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">n! = \begin{cases}
1 \qquad n = 0 \\
n \times (n - 1) \qquad n \neq 0
\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:2em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:2em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<pre data-role="codeBlock" data-info="c#" class="language-c# c#"><code>long fact(int n)
{
    if(n == 0)
    {
        return 1;
    } else {
        return (n * fact(n -1));
    }
}
</code></pre><p>递归算法的设计步骤如下</p>
<ol>
<li>将规模较大的原问题分解为一个或多个规模更小，但具有类似于原问题特性的子问题，即较大的问题递归地用较小的子问题来描述，解原问题的方法同样可用来解这些子问题</li>
<li>确定一个或多个无须分解，可直接求解的最小子问题（称为“递归的终止条件”）</li>
</ol>
<p>递归算法有两个基本的特征：递归归纳和递归终止。首先能将问题转化为比原问题规模小的同类问题，归纳出一般递推公式，故所处理的对象要有规律地递增或递减；当规模小到一定的程度应结束递归调用，逐层返回</p>
<h2 id="队列">队列 </h2>
<p>它只允许插入在表的一端进行，而删除在表的另一端进行，允许插入的一端叫队尾（rear），而允许删除的一端叫队头（front）。队列的插入操作通常称为“入队”或“进队”，而队列的删除操作则称为“出队”或“退队”;队”。当队列中无数据元素时，称为“空队列”。根据队列的定义可知，队头元素总是最先进队列，也总是最先出队列；队尾元素总是最后进队列，因而也是最后出队列。这种表是按照先进先出（first in first out FIFO）的原则组织数据的，因此，队列也被称为“先进先出”表</p>
<h2 id="分治法">分治法 </h2>
<p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单地直接求解，原问题的解即子问题的解的合并</p>
<p>任何一个可以用计算机求解的问题，其所需的计算时间都与规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少</p>
<p>分治法所能解决的问题一般具有以下几个特征。</p>
<ul>
<li>该问题的规模缩小到一定的程度就可以容易地解决。</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解。</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题</li>
</ul>
<p>分治法在每一层递归上都有如下三个步骤</p>
<ol>
<li>分解：将原问题分解为若干个规模较小、相互独立，且与原问题形式相同的子问题。</li>
<li>解决：若子问题规模较小且容易被解决则直接解，否则递归地解各个子问题。</li>
<li>合并：将各个子问题的解合并为原问题的解。</li>
</ol>
<p><a href="https://ebook.hep.com.cn/index.html#/reader?bookId=1061913534566236161">原文地址</a></p>

      </div>
      <div class="md-sidebar-toc">
<div class="md-toc">
<details style="padding:0;;padding-left:0px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#栈和队列" class="md-toc-link"><p>栈和队列</p>
</a>
          </summary>
        <div>
          <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#栈" class="md-toc-link"><p>栈</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#多栈共享邻接空间" class="md-toc-link">
            <p>多栈共享邻接空间</p>

          </a></div>
        </div>
      </details>
    <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#应用" class="md-toc-link">
            <p>应用</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#队列" class="md-toc-link">
            <p>队列</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#分治法" class="md-toc-link">
            <p>分治法</p>

          </a></div>
        </div>
      </details>
    
</div>
</div>
      <a id="sidebar-toc-btn">≡</a>
    
    
    
    
    
    
<script>

var sidebarTOCBtn = document.getElementById('sidebar-toc-btn')
sidebarTOCBtn.addEventListener('click', function(event) {
  event.stopPropagation()
  if (document.body.hasAttribute('html-show-sidebar-toc')) {
    document.body.removeAttribute('html-show-sidebar-toc')
  } else {
    document.body.setAttribute('html-show-sidebar-toc', true)
  }
})
</script>
      
  
    
          </div>
        </section>
      </div>
    </main>
</body>

</html>