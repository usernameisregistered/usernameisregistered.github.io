
<!DOCTYPE html>
<html lang="en">
<title>计算机图形学-02直线的扫描转换</title>
<script src="https://cdn.jsdelivr.net/npm/texme@0.7.0"></script>
<textarea>
[3.2直线的扫描转换.pdf](uploads/2f51af9da4f4c5f733ad0314c001bc53/3.2直线的扫描转换.pdf)

> 对直线的扫描转换就是要在二维光栅格上计算接近或者位于理想的无限细的直线上的像素的坐
标

为了可视化几何属性，SRGP将一个像素表达成一个圆形的点，并且其中心就是像素在整数栅格上颚的点(x,y)坐标

## 基本增量算法 DDA

对线的扫描转换，最简单的策略就是将斜率m计算为△y/△x,然后从最左端的点开始，对x每次递增一个单位，而对每个$x_i$，计算其相对应的$y_i = mx_i + b$,并显示坐标为($x_i, Round(y_i)$)的像素，其中Round$(y_i)$=Floor(0.5 + $y_i$)
$$
y_{i+1} = mx_{i+1} + b = m(x_i + \Delta x) + b = y_i + m\Delta x
$$
当$\Delta x = 1$时, $y_{i+1} = y_i + m$;表示x每增加一个单位，y就加上一个m,m为直线的斜率

```c
// 以下代码仅仅适用于 $-1 \leq m \leq 1$的情况。
void Line(int x0, int y0, int x1, int y1)
{
    int x;
    float dx, dy, y, m;
    dy = y1 - y0;
    dx = x1 - x0;
    m = dy / dx;
    y = y0;
    for(x = x0; x <= x1; x++){
        //绘制点函数
        y += m
    }
}
```

## 中点线算法 BresenHam

针对DDA算法，有明显的缺点：对y值取整需要花费时间，而且因为斜率是一个小数。y和m必须是实数或者二进制小数，因此提出优化算法

*一下所描述的情况适用于斜率为0和1之间，左下端点$(x_0, y_0)$,右上端点$(x_1, y_1)$,*

设定以绘制一个点$(x_p,y_p)$;则下一个点位的可选位置有2个即：E$(x_p + 1, y_p)$或者NE $(x_p + 1, y_p + 1)$, 假定直线与$x_p + 1$的网格线相交于点Q,则根据NE和E到Q的垂直距离，选择距离Q最近的像素点。二作为被扫描转化线的最好逼近则是使用中点$(x_p + 1, y_p + 0.5)$

假设直线的隐函数为$F(x, y) = ax + by + c$; 斜截式的方程为$y = \frac{dy}{dx} + b$
$F(x, y) = dy \times x - dx \times y  + b \times dx = 0$;
则$a = dy, b = -dx, c = b \times dx$

容易证明 对于线上面的点F(x, y) = 0; 对于在线下方的点F(x, y)为正数，在线上方的点F(x, y)为负数，则我们只需要计算$F(x_p + 1, y_p + 0.5)$的符号即可。

由于是在点$(x_p + 1, y_p + 0.5)$的函数值上判定的，因此可以定义一个判定变量d = $F(x_p + 1, y_p + 0.5)$;

当栅格线移动到下一条时, 选择的是点时E$(x_p + 1, y_p)$，则有
$$
d_{new} = F(x_p + 2, y_p + 0.5) = a(x_p + 2) + b(y_p + 0.5) +c  \\
d_{old} = a(x_p + 1) + b(y_p + 0.5) + c \\
d_{new} = d_{old} + a =  d_{old} + dy \\
\Delta d = a
$$
当栅格线移动到下一条时，选择的是点时NE$(x_p + 1, y_p + 1)$， 则有
$$
d_{new} = F(x_p + 2, y_p + 1.5) = a(x_p + 2) + b(y_p + 1.5) +c  \\
d_{old} = a(x_p + 1) + b(y_p + 0.5) + c \\
d_{new} = d_{old} + a +  b \\
\Delta d = a + b
$$

第一个点位$(x_0, y_0)$, 则初始的d为
$$
F(x_0 + 1, y_0 + 0.5)  \\
= a(x_0 + 1) + b(y_0 + 0.5) + c \\
= ax_0 + a + by_0 + 0.5b + c \\
= F(x_0, y_0) + a + 0.5b;
$$
为减少浮点数的计算并且扩大倍数符号不变 则将上式*2
$d_{start}=2a + b$
$\Delta d = 2\Delta d$

```c
int Line(int x0, int y0, int x1, int y1)
{
    int dx, dy, incrE, incrNE, d, x, y;
    dx = x1 - x0;
    dy = y1 - y0;
    d = dy * 2 - dx
    incrE = dy * 2
    incrNE = (dy  - dx) * 2
    x = x0;
    y = y0;
    while(x < x1){
        if(d <= 0){
            d+= incrE;
            x++;
        } else {
            d+= incrNE;
            x++;
            y++;
        }
    }
}
```


</textarea>