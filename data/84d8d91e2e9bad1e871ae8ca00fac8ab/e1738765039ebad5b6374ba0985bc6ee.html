
<!DOCTYPE html>
<html lang="en">
<title>计算机图形学-03圆的扫描转换</title>
<script src="https://cdn.jsdelivr.net/npm/texme@0.7.0"></script>
<textarea>
[3.3圆的扫描转换.pdf](uploads/d9ea51065591bcf2a680f467fffd2ea6/3.3圆的扫描转换.pdf)

> 尽管SRGP中不支持圆但它支持椭圆这种图元，因此可以将圆弧当做一种特殊的椭圆弧并根据圆的八重对称性很好的生成圆，这种处理对圆的裁剪和扫描转换都是适用的，圆心在坐标的圆的方程为$x^2 + y^2 = R^2  $.若圆心不在坐标原点，通过平移操作就能将圆心移到坐标原点，但其后的扫描转换时，像素的位置要做适当的平移修正，

$$
y = \pm \sqrt{R^2 - x^2}
$$

可以先画出圆的四分之一。其他的根据圆的四分对称性得出

## 八方向对称性

假设圆心在坐标原点。存在点$(x, y)$在圆上，根据八对称性很容易得到其他的7个点分别为$(-x,y),(x,-y),(-x,-y),(y,x),(-y,x),(y,-x),(-y,-x)$

## 中点圆算法

我们只考虑为$45^o$的一段圆弧，即从$x=0到x=y=\frac{R}{\sqrt{2}}$的第二个八分圆弧，其他的根据八方向对称性得出即可。

原理：在2个像素之间的中点出给出一个评估函数值，并据此在2个像素中选择更靠近圆的哪个像素

设函数$F(x,y)=x^2 + y^2 - R^2$,对于圆上的点，次函数的值为0，对于圆内的点，函数值为正数，而圆外的点，函数值为负数。如此，如果中点在圆外。则选取园内的点，如果中点在园内，则选择圆外的店即可

设定圆的绘制方向为顺时针绘制
$$
d_{old} = F(x_p + 1 , y_p - \frac{1}{2}) = (x_p + 1)^2 + (y_p - \frac{1}{2}))^2 -R^2 \\
d_{new} = F(x_p + 2, yp - \frac{1}{2})  (x_p + 2)^2 + (y_p - \frac{1}{2}))^2 -R^2 \text{选择的点为圆外的点} \\
d_{new} = d_{old} + 2x_p + 3
$$

$$
d_{old} = F(x_p + 1 , y_p - \frac{1}{2}) = (x_p + 1)^2 + (y_p - \frac{1}{2}))^2 -R^2 \\
d_{new} = F(x_p + 2, yp - \frac{3}{2})  (x_p + 2)^2 + (y_p - \frac{3}{2}))^2 -R^2 \text{选择的点为圆内的点} \\
d_{new} = d_{old} + 2x_p - 2y_p + 5
$$

和直线不同的是，直线的$\Delta$是常量，但是圆的$\Delta$是变量，并且依赖与上一步所选择的点P的坐标。由于圆的$\Delta$是以点P为自变量表达的，所以我们称之为估值点。

计算初始值: 由于限定算法处理的是整数，并只画八分之一的圆弧。因此起始点位(0, R)下一个点的中点为(1, R - 1/2);
$$
F(1, R- 1/2) = 1 + R^2 - R + 1/ 4 - R^2 = 5/4 - R;
$$

```c

void Circle(int radius)
{
    int x, y
    float d;
    x = 0;
    y = radius
    d = 5/4 - radius;
    while(y > x){
        if(d < 0){
            d+= 2 * x +3
            x++
        } else {
            d += (x -y) * 2 + 5
            x++;
            y--
        }
    }
}
```


</textarea>