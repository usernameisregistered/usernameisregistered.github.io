import{_ as a,c as e,o as t,a2 as r}from"./chunks/framework.Bc4oNHcE.js";const f=JSON.parse('{"title":"02浏览器存储限制和清理标准","description":"","frontmatter":{"layout":"doc","title":"02浏览器存储限制和清理标准"},"headers":[],"relativePath":"database/IndexedDB/02浏览器存储限制和清理标准.md","filePath":"database/IndexedDB/02浏览器存储限制和清理标准.md"}'),o={name:"database/IndexedDB/02浏览器存储限制和清理标准.md"},l=r('<h1 id="浏览器存储限制和清理标准" tabindex="-1">浏览器存储限制和清理标准 <a class="header-anchor" href="#浏览器存储限制和清理标准" aria-label="Permalink to &quot;浏览器存储限制和清理标准&quot;">​</a></h1><p>一般来说，数据存储的类型主要有以下两种</p><ol><li>持久化存储：这种数据是希望长久保留的，只有的当用户选择清除才会被删除掉</li><li>临时存储：这种数据不用保存很久，当最近一次使用时储存限制达到限制大小就会被自动清理掉</li></ol><h2 id="数据存储在哪里" tabindex="-1">数据存储在哪里？ <a class="header-anchor" href="#数据存储在哪里" aria-label="Permalink to &quot;数据存储在哪里？&quot;">​</a></h2><p>每种存储类型代表一个单独的存储库。这是用户 Firefox 配置文件下目录的实际映射</p><ul><li><strong>profile</strong>/storage——配额管理器维护的主要顶级目录</li><li><strong>profile</strong>/storage/permanent——持久数据存储库</li><li><strong>profile</strong>/storage/temporary——临时数据存储库</li><li><strong>profile</strong>/storage/default——默认数据存储库</li></ul><h2 id="数据储存限制" tabindex="-1">数据储存限制 <a class="header-anchor" href="#数据储存限制" aria-label="Permalink to &quot;数据储存限制&quot;">​</a></h2><p>浏览器的最大存储空间是动态的——它取决于你的硬盘大小。全局限制为可用磁盘空间的50％。在Firefox中，一个名为Quota Manager的内部浏览器工具会跟踪每个源用尽的磁盘空间，并在必要时删除数据。</p><p>因此，如果你的硬盘驱动器是500GB，那么浏览器的总存储容量为 250GB。如果超过此范围，则会发起称为源回收的过程，删除整个源的数据，直到存储量再次低于限制。删除源数据没有只删一部分的说法——因为这样可能会导致不一致的问题。</p><p>还有另一个限制称为组限制——这被定义为全局限制的20％，但它至少有10MB，最大为 2GB。每个源都是一组（源组）的一部分。</p><h2 id="lru-策略" tabindex="-1">LRU 策略 <a class="header-anchor" href="#lru-策略" aria-label="Permalink to &quot;LRU 策略&quot;">​</a></h2><p>当可用磁盘空间已满时，配额管理器将根据 LRU 策略开始清除数据——最近最少使用的源将首先被删除，然后是下一个，直到浏览器不再超过限制。</p><p>我们使用临时存储跟踪每个源的“上次访问时间”。一旦达到临时存储的全局限制（之后会有更多限制），我们将尝试查找所有当前未使用的源（即没有打开选项卡/应用程序的那些来保持打开的数据存储）。然后根据“上次访问时间”对它们进行排序。然后删除最近最少使用的源，直到有足够的空间来满足触发此源回收的请求</p>',13),i=[l];function n(s,_,d,p,c,h){return t(),e("div",null,i)}const m=a(o,[["render",n]]);export{f as __pageData,m as default};
