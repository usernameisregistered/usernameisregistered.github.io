import{_ as t,c as d,o as r,a2 as a}from"./chunks/framework.Bc4oNHcE.js";const m=JSON.parse('{"title":"03栈和队列","description":"","frontmatter":{"layout":"doc","title":"03栈和队列"},"headers":[],"relativePath":"algorithm/数据结构与算法/03栈和队列.md","filePath":"algorithm/数据结构与算法/03栈和队列.md"}'),o={name:"algorithm/数据结构与算法/03栈和队列.md"},e=a('<h1 id="栈和队列" tabindex="-1">栈和队列 <a class="header-anchor" href="#栈和队列" aria-label="Permalink to &quot;栈和队列&quot;">​</a></h1><blockquote><p>栈只允许在表的一端进行插入或删除操作，而队列只允许在表的一端进行插入操作、在另一端进行删除操作。因而，栈和队列也可以被称为操作受限的线性表</p></blockquote><h2 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to &quot;栈&quot;">​</a></h2><p>栈(stack)是一种只允许在一端进行插入和删除操作的线性表，它是一种操作受限的线性表。在表中允许进行插入和删除的一端称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong>。栈的插入操作通常称为<strong>入栈</strong>或<strong>进栈</strong>而栈的删除操作则称为<strong>出栈</strong>或<strong>退栈</strong>当栈中无数据元素时，称为<strong>空栈</strong></p><p>根据栈的定义，每次进栈的元素都被放在原栈顶元素之上而成为新的栈顶，而每次出栈的总是当前栈中“最新”的元素，即最后进栈的元素;<strong>后进先出</strong></p><h3 id="多栈共享邻接空间" tabindex="-1">多栈共享邻接空间 <a class="header-anchor" href="#多栈共享邻接空间" aria-label="Permalink to &quot;多栈共享邻接空间&quot;">​</a></h3><p>G在计算机系统软件中，各种高级语言的编译系统都离不开栈的使用。常常一个程序中要用到多个栈，若采用顺序栈，会因为所需的栈空间大小难以准确估计，导致出现有的栈空间溢出、有的栈空间空闲的情况。为了不发生上溢错误，就必须给每个栈预先分配一个足够大的存储空间，但实际中很难准确地估计。另一方面，若每个栈都预分配过大的存储空间，势必会造成系统空间紧张。紧张。若让多个栈共用一个足够大的连续存储空间，则可利用栈的动态特性使其存储空间互补。这就是栈的共享邻接空间。</p><h2 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h2><ol><li>算术表达式求值</li></ol><p>计值的实现可以通过设置两个栈来完成。 <strong>操作数栈(OPRD)</strong>: 用来存放处理表达是过程中的操作数 <strong>运算符栈(OPTR)</strong>: 存放处理表达式过程中的运算符，开始时，先在运算符栈栈底压入一个表达式的结束符*#* 计算机系统在处理表达式时，从左到右依次读出表达式中的各个符号（操作数或运算符），每读出一个符号后，根据运算规则做如下的处理。假如是操作数，则将其压入操作数栈，并依次读下一个符号。假如是运算符，则与运算符栈的栈顶运算符进行优先级比较，并做以以下处理</p><ul><li>假如读出的运算符的优先级高于运算符栈栈顶运算符的优先级，则将其压入运算符栈，并依次读下一个符号</li><li>假如读出的运算符的优先级等于运算符栈栈顶运算符的优先级，说明左右括号相遇，只需将栈顶运算符退栈即可</li><li>#假如读出的运算符的优先级低于运算符栈栈顶运算符的优先级，则从操作数栈连续退出两个操作数，从运算符栈中退出一个运算符，然后做相应的运算，并将运算结果压入操作数栈</li><li>假如读出的是表达式结束符*#<em>，且运算符栈栈顶的运算符也为</em>#*，则表达式处理结束，最后的表达式的计算结果在操作数栈的栈顶位置</li></ul><p>表1 表达式3+4*2计算过程栈区变化表</p><table><thead><tr><th>序号</th><th>操作数栈</th><th>运算符栈</th><th>尚待读入的表达式</th><th>注释</th></tr></thead><tbody><tr><td>1</td><td></td><td>#</td><td>3+4*2#</td><td>初始状态</td></tr><tr><td>2</td><td>3</td><td>#</td><td>+4*2#</td><td>读入3</td></tr><tr><td>3</td><td>3</td><td>#+</td><td>4*2#</td><td>读入+</td></tr><tr><td>4</td><td>3,4</td><td>#+</td><td>*2#</td><td>读入4</td></tr><tr><td>5</td><td>3,4</td><td>#+*</td><td>2#</td><td>读入2#</td></tr><tr><td>6</td><td>3,4，2</td><td>#+*</td><td>#</td><td>读入2</td></tr><tr><td>7</td><td>3， 8</td><td>#+</td><td>#</td><td>计算4*2</td></tr><tr><td>8</td><td>11</td><td>#</td><td>#</td><td>计算3+8</td></tr><tr><td>9</td><td></td><td></td><td></td><td>结束</td></tr></tbody></table>',13),n=[e];function s(l,i,h,_,c,g){return r(),d("div",null,n)}const u=t(o,[["render",s]]);export{m as __pageData,u as default};
