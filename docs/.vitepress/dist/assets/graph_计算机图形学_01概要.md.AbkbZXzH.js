import{_ as a,c as e,o as t,a2 as r}from"./chunks/framework.Bc4oNHcE.js";const P=JSON.parse('{"title":"01概要","description":"","frontmatter":{"layout":"doc","title":"01概要"},"headers":[],"relativePath":"graph/计算机图形学/01概要.md","filePath":"graph/计算机图形学/01概要.md"}'),o={name:"graph/计算机图形学/01概要.md"},n=r('<h1 id="概要" tabindex="-1">概要 <a class="header-anchor" href="#概要" aria-label="Permalink to &quot;概要&quot;">​</a></h1><p>光栅图形软件包近似做出数学意义上的图元。这个图元被定义在笛卡尔坐标系的网格点上。用适当亮度或者色彩的像素点来表示。这些像素一般作为位图或者像素图存储在CPU内存或者帧缓存中。</p><h2 id="显示系统体系结构的含义" tabindex="-1">显示系统体系结构的含义 <a class="header-anchor" href="#显示系统体系结构的含义" aria-label="Permalink to &quot;显示系统体系结构的含义&quot;">​</a></h2><p>SRGP的程序可以分成两部分。一部分是输出流水线，另一部分是输入流水线</p><p>在输出流水线中，应用程序根据应用模型或数据结构中存储的或退到的图元和属性对物体进行描述，并将这些信息传递给图形包，有图形包将它们裁剪和扫描转换为最终在屏幕上显示的像素。 在输入流水线中，在显示终端的用户交互操作由图形包的采样程序或者事件驱动输入程序转换成度量信息。并将这些信息传递给应用程序，然后应用程序根据这些度量信息对模型或者屏幕上的图像进行修改；与输入相关的程序包括：初始化和控制输入设备的程序、在交互过程中从输入设备获取度量信息的程序。</p><p>实现一个SRGP图形包必须充分考虑各种显示器。有些显示器系统带有自己的帧缓存和显示控制器。这些显示控制器的工作就是解释和执行绘图命令，将生成像素写入帧缓；另外一些简单的系统只可直接又CPU进行刷新。其图形包的只输出部分可以驱动光栅硬拷贝设备。</p><h3 id="具有帧缓存和显示控制器的显示器" tabindex="-1">具有帧缓存和显示控制器的显示器 <a class="header-anchor" href="#具有帧缓存和显示控制器的显示器" aria-label="Permalink to &quot;具有帧缓存和显示控制器的显示器&quot;">​</a></h3><p>SRGP只需将它关于图元、属性和写模式的内部表示转化成显示外设能够直接绘图的方式即可</p><h3 id="只有帧缓存的显示器" tabindex="-1">只有帧缓存的显示器 <a class="header-anchor" href="#只有帧缓存的显示器" aria-label="Permalink to &quot;只有帧缓存的显示器&quot;">​</a></h3><p>SRGP自身进行扫描转换已生成屏幕画面外的画布和帧缓存图像。</p><h3 id="硬拷贝设备" tabindex="-1">硬拷贝设备 <a class="header-anchor" href="#硬拷贝设备" aria-label="Permalink to &quot;硬拷贝设备&quot;">​</a></h3><p>SRGP必须生成完整的位图或者像素图。并一次扫描出一条线传递给输出设备</p><p><strong>裁剪</strong>： 图元中不在裁剪框中的图像不显示</p>',13),h=[n];function i(s,l,c,p,_,d){return t(),e("div",null,h)}const m=a(o,[["render",i]]);export{P as __pageData,m as default};
